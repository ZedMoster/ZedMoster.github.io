{"meta":{"title":"龙|Engineer|BIMer","subtitle":"轨迹","description":"记录学习轨迹","author":"龙","url":"https://zedmoster.github.io","root":"/"},"pages":[{"title":"about","date":"2021-02-07T16:00:00.000Z","updated":"2021-02-08T20:03:27.623Z","comments":true,"path":"about/index.html","permalink":"https://zedmoster.github.io/about/index.html","excerpt":"","text":"专业：土木工程（2017） 职业：软件工程师、建筑设计师 学习：BIM、python、C#"},{"title":"categories","date":"2021-02-08T08:34:08.000Z","updated":"2021-02-08T11:26:23.807Z","comments":true,"path":"categories/index.html","permalink":"https://zedmoster.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2021-02-08T08:34:16.000Z","updated":"2021-02-08T11:32:16.602Z","comments":true,"path":"search/index.html","permalink":"https://zedmoster.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-08T08:33:55.000Z","updated":"2021-02-08T11:26:16.317Z","comments":true,"path":"tags/index.html","permalink":"https://zedmoster.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2.13 提示 TaskDialog","slug":"PythonScriptPrimer/2.13 提示TaskDialog","date":"2021-02-09T00:08:19.000Z","updated":"2021-02-08T20:40:22.276Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.13 提示TaskDialog/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.13%20%E6%8F%90%E7%A4%BATaskDialog/","excerpt":"","text":"创建 TaskDialogTaskDialogs 是 Revit 中的用于提供详细的用户反馈 API 类。它们可以用一行代码执行，如下所示： 1TaskDialog.Show(&quot;Example Title&quot;, &quot;Example Text&quot;) TaskDialogs 可用于向用户提供一定程度的反馈，可能时想报告脚本是成功运行还是遇到什么错误等情况。 自定义 TaskDialogTaskDialog 也可以通过类的属性对其进行编辑，以使内容更加丰富，例如： 1234567task_dialog = TaskDialog(&quot;Example Title&quot;)task_dialog.CommonButtons = TaskDialogCommonButtons.Cancel | TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Close | TaskDialogCommonButtons.No | TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.Retry | TaskDialogCommonButtons.Nonetask_dialog.FooterText = &quot;Example Footer Text&quot;task_dialog.MainInstruction = &quot;Example Main Instruction&quot;task_dialog.MainContent = &quot;This is the main content for this TaskDialog&quot;task_dialog.Show() 提示窗口样式","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.12 内置类别","slug":"PythonScriptPrimer/2.12 内置类别","date":"2021-02-09T00:08:18.000Z","updated":"2021-02-08T20:37:04.254Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.12 内置类别/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.12%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%88%AB/","excerpt":"","text":"BuiltInCategoryRevit 用户界面向用户显示了许多类别，例如门，楼板和常规模型等。Revit 在内部使用更详细的类别列表，称为内置类别。内置类别的完整列表可以在 BuiltInCategory 枚举中找到-这些是固定编码，不能创建修改。 检索类别元素由于该列表涵盖了近 1000 个类别，因此可以帮助我门更精确地定位 Revit 元素。内置类别对于 FilteredElementCollectors 尤其有用，它使我们能够准确检索特定的元素。 例如，要收集文档中的所有 面积标签 ： 12area_tags = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_AreaTags).ToElements()OUT = area_tags","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.11 Units 单位处理","slug":"PythonScriptPrimer/2.11 Units单位处理","date":"2021-02-09T00:08:17.000Z","updated":"2021-02-08T20:36:44.474Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.11 Units单位处理/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.11%20Units%E5%8D%95%E4%BD%8D%E5%A4%84%E7%90%86/","excerpt":"","text":"Revit 长度Revit 长度内部单位：英尺 123detail_line = UnwrapElement(IN[0])decimal_feet_length = detail_line.GeometryCurve.LengthOUT = decimal_feet_length # 单位：英尺 上面代码返回的数据单位并不是我们常用的毫米单位，所以需要对数据进行单位转换。 单位转换（毫米）使用 Revit 的 UnitUtils 类，且参数只能从 Revit 的 DisplayUnitType 枚举中选择值类型 1234detail_line = UnwrapElement(IN[0])decimal_feet_length = detail_line.GeometryCurve.Lengthmetric_length = UnitUtils.Convert(decimal_feet_length, DisplayUnitType.DUT_DECIMAL_FEET, DisplayUnitType.DUT_MILLIMETERS) # 将英尺转换为毫米OUT = metric_length # 单位：毫米 角度单位转换（弧度）Revit 角度内部单位：弧度 123angle = 90.0 # 角度值radians_equivalent = UnitUtils.Convert(angle, DisplayUnitType.DUT_DECIMAL_DEGREES, DisplayUnitType.DUT_RADIANS) # 将角度转换为弧度OUT = radians_equivalent # 单位：弧度","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.10 提示用户界面选择","slug":"PythonScriptPrimer/2.10 提示用户界面选择","date":"2021-02-09T00:08:16.000Z","updated":"2021-02-08T20:36:20.795Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.10 提示用户界面选择/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.10%20%E6%8F%90%E7%A4%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E9%80%89%E6%8B%A9/","excerpt":"","text":"用户选择工作流程有时我们可能会构建一个通用工具，要求用户选择文档中的 Revit 元素（例如，元素重新编号工具）。这将需要无限数量的可自定义过滤器，以使用户能够使用逻辑选择他们选择的元素，但是我们可以通过提示用户选择某些内容来跳过整个问题。 ISelectionFilter 接口ISelectionFilter 可以限制用户可以选择的元素种类。只需要创建一个实现该接口的新类。 然后，将此类的实例作为参数提供给 PickElementsByRectangle() 方法。例如，提示用户选择 Walls 所需的代码为： 123456789101112131415# 加载过滤选择的接口 ISelectionFilterfrom Autodesk.Revit.UI.Selection import ISelectionFilter# 定义选择过滤器class MySelectionFilter(ISelectionFilter): def __init__(self): pass def AllowElement(self, element): return element.Category.Name == &quot;墙&quot; def AllowReference(self, element): return Falseselection_filter = MySelectionFilter() # 仅选择墙walls = uidoc.Selection.PickElementsByRectangle(selection_filter) # 返回框选的墙体OUT = walls","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.9 批处理文档","slug":"PythonScriptPrimer/2.9 批处理文档","date":"2021-02-09T00:08:15.000Z","updated":"2021-02-08T20:36:01.174Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.9 批处理文档/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.9%20%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/","excerpt":"","text":"批处理 Revit 文件 Revit API 的最强大功能之一就是能够以自动方式打开，关闭，编辑和保存文档。最重要的是，我们可以“无头”实现这一目标，这意味着无需任何 GUI 组件即可打开 Revit 文档的数据库。一般而言，以这种方式处理文档可能比用户这样做快 20 到 30 倍-这意味着构建涉及快速批处理许多文件时可以使用这种方式。 批处理步骤： 根据目标文档的文件路径，创建 Revit FilePath 对象的列表，遍历此文档路径列表 使用 Revit API 的 Open() 方法打开文件并为此打开的文档创建一个句柄 通过其句柄打开针对我们新打开的文档的处理 根据需求进行 API 调用，具体取决于要执行的具体操作 关闭打开文档。如果需要保存更改，可将文档进行另存。 python 节点代码123456789101112131415input_paths = IN[0]# 设置打开方式open_options = OpenOptions()report = []for path in input_paths: filepath = FilePath(path) # 打开文件 family_doc = app.OpenDocumentFile(filepath, open_options) dimensions = FilteredElementCollector(family_doc).OfCategory(BuiltInCategory.OST_Dimensions).WhereElementIsNotElementType().ToElements() number_dimensions = len(dimensions) report.append(&quot;File &#123;&#125; contains &#123;&#125; dimensions&quot;.format(path, number_dimensions)) # 关闭文件 family_doc.Close(False)OUT = report #Outputting the report we generated dynamo 节点","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.8 处理事务 Transactions","slug":"PythonScriptPrimer/2.8 处理事务 Transactions","date":"2021-02-09T00:08:14.000Z","updated":"2021-02-08T20:35:45.647Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.8 处理事务 Transactions/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.8%20%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%20Transactions/","excerpt":"","text":"Revit 是数据库需要对该数据库的更改进行仔细的排序，需要对过程进行管理和检查（针对架构的有效性以及针对 Revit API 设计的合法性）。所有这些都由 Revit 的本机 Transaction API 处理。 Dynamo’s TransactionManager当直接为 Revit API 编码时，我们可以通过使用代码实例化 Transaction 类的新对象并调用其 Start() 方法来简单地启动新事务。但是，在 Dynamo 中，我们通常使用下面这种方式进行处理。 TransactionManager 是 Dynamo API 的一部分，该 API 处理 Dynamo 应用程序中对 Revit 文档数据库所做的更改： 1234TransactionManager.Instance.EnsureInTransaction(doc) # 为 doc 文档开启事务# 增、删、改操作Revit文档TransactionManager.Instance.TransactionTaskDone() # 提交更新 简而言之，主体代码都写在样板代码的这两行代码之间即可。","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.7 访问图元参数 Parameters","slug":"PythonScriptPrimer/2.7 访问图元参数 Parameters","date":"2021-02-09T00:08:13.000Z","updated":"2021-02-08T20:35:15.734Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.7 访问图元参数 Parameters/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.7%20%E8%AE%BF%E9%97%AE%E5%9B%BE%E5%85%83%E5%8F%82%E6%95%B0%20Parameters/","excerpt":"","text":"族、族类型、族实例之间的关系Revit 的族系使用族类型和族实例之间的层次关系。API 中并行存在相同的关系： 族实例 是 Revit 的 FamilyInstance 类的实例。例如：项目中创建的门、窗 族类型 是 Revit 的 FamilyType 类的实例。例如：防火门 FM1822 类型 族实例参数通过 FamilyInstance 对象访问，而族类型的参数通过实例的 FamilyType 类型对象访问。 包含关系：FamilyInstance -&gt; FamilyType -&gt; Family 每个FamilyInstance都是通过FamilyType创建。同样，每个FamilyType将由项目文档中的加载的Family族文件定义。 下面演示如何从FamilyInstance向上找到FamilyType类型，再通过FamilyType找到Family族： 12345family_instance = UnwrapElement(IN[0]) # 展开dynamo图元得到Revit族实例family_type_id = family_instance.GetTypeId() # 获取族实例的类型Idfamily_type = doc.GetElement(family_type_id) # 通过类型Id获取族类型family = family_type.Family # 通过类型获取族FamilyOUT = family_instance, family_type, family # 输出 [族实例, 族类型, 族] 反方向查找：Family对象通常包含多个的FamilyType对象之间存在多对一的关系。同样，有许多放置相同FamilyType的FamilyInstances。要获得一个家庭的所有 family_type，我们可以使用： 1234family = UnwrapElement(IN[0]) # 展开dynamo图元得到Revit族family_type_ids = family.GetFamilySymbolIds() # 获取族包含的所有类型Idfamily_types = [doc.GetElement(id) for id in family_type_ids] # 获取所有的族类型存再列表中OUT = family_types # 输出族类型列表 寻找特定类型的所有FamilyInstance对象是那么简单-我们首先需要创建一个 FamilyInstanceFilter 使用所需FamilyType的 ID。 12345678910111213141516# 展开dynamo图元得到Revit族family = UnwrapElement(IN[0])# 获取族包含的所有类型Idfamily_type_ids = family.GetFamilySymbolIds()# 创建族实例列表family_instances = []# 寻找类型对应的实例for family_type_id in family_type_ids: # 创建指定类型的过滤器 family_instance_filter = FamilyInstanceFilter(doc, family_type_id) # 获取文档中所有类型的实例对象 elements = FilteredElementCollector(doc).WherePasses(family_instance_filter).ToElements() # 将实例对象添加到列表 family_instances.append(elements)# 输出结果OUT = family_instances 族实例和族类型参数获取族实例参数如果要与传递 Dynamo 元素到节点中与 Revit 元素进行交互，则需要将其展开。展开后，可以访问特定参数将所有元素实例参数的列表作为 Parameter 对象返回，可以通过其 Element.Parameters 属性访问，如下所示： 12family_instance = UnwrapElement(IN[0]) # 族实例对象instance_parameters = family_instance.Parameters # 实例包含的所有参数 获取族类型参数类型参数需要通过元素的族类型来访问。如果将FamilyInstance作为输入，则首先需要获取元素的 FamilyType 对象，例如 GetTypeId() 此方法返回元素的族类型的ElementId。然后，我们可以使用 doc.GetElement() 方法返回元素的FamilyType对象。 123family_instance = UnwrapElement(IN[0]) # 族实例对象family_type = doc.GetElement(family_instance.GetTypeId()) # 通过实例获取类型type_parameters = family_type.Parameters # 类型包含的所有参数 访问指定参数对于获取 FamilyInstance 或 FamilyType 的参数，有以下方法来访问特定参数： Element.LookupParameter() Element.get_Parameter() 这两种方法本质上都是相同的。它们返回一个 Parameter 对象。选择 Revit 门实例对象： 获取参数值12input_element = UnwrapElement(IN[0])paratemer = input_element.LookupParameter(&quot;顶高度&quot;) 如果输出原始Parameter对象，它将显示为Autodesk.Revit.DB.Parameter，为了获取参数 Parameter 对象的值，您需要使用 Parameter 类的对其进行转换。 依据判断值的类型进行取值即可： AsDouble() AsElementId() AsInteger() AsString() AsValueString() 使用上面的方法以适当的数据类型返回值。 12input_element = UnwrapElement(IN[0])value = input_element.LookupParameter(&quot;顶高度&quot;).AsValueString() # value = 2400 此工作流程等效于在 Dynamo 中使用 GetParameterValueByName 节点。 设置参数值同样需要获取到Parameter对象，使用 Set() 方法进行赋值即可,当然更改参数的这个操作修改了文件的内容，所以应该开启 Transaction 事务。 。 1234TransactionManager.Instance.EnsureInTransaction(doc) # 事务开始input_element = UnwrapElement(IN[0])input_element.LookupParameter(&quot;顶高度&quot;).Set(2000)TransactionManager.Instance.TransactionTaskDone() # 事务结束 Set 值对象的类型包括： Set(float) Set(int) Set(ElementId) Set(str)","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.6 几何(Geometry)转换","slug":"PythonScriptPrimer/2.6 几何(Geometry)转换","date":"2021-02-09T00:08:12.000Z","updated":"2021-02-08T20:35:05.332Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.6 几何(Geometry)转换/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.6%20%E5%87%A0%E4%BD%95(Geometry)%E8%BD%AC%E6%8D%A2/","excerpt":"","text":"Revit 几何图形和 Dynamo 几何图形Dynamo 具有与 Revit 并行的类库。意味着需要使用特殊的转换方法来使两者之间进行转换实现数据交互。前面章节也提到过需要展开对象。 转换方式您可以使用 Dynamo API 的转换方法轻松地在 Dynamo 和 Revit 几何类型之间进行切换: ToProtoType() ToDSType() ToLine() ToPoint() ToVector() ToXyz() PointsRevit 点在 3D 空间中由其 X，Y 和 Z 坐标定义。创建方法：先创建点的对象 Autodesk.Revit.DB.XYZ，在创建 Revit 点 Autodesk.Revit.DB.Point.Create 方法创建，该方法需要传入点的对象。 12XYZ revit_xyz = new Autodesk.Revit.DB.XYZ(0,0,0) // 创建点对象Point revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz) // 创建点 要创建 Dynamo 点，我们需要使用 Designscript 库，该库是 Dynamo 的一部分。Dynamo 点的类型为 Autodesk.DesignScript.Geometry.Point 如果从 Python 节点输出以下 dynamo_point，它将立即显示在 Dynamo 的 3D 背景预览中。 12dynamo_point = Autodesk.DesignScript.Geometry.Point.ByCoordinates(0,0,0) # 创建点OUT = dynamo_point # 输出点视图将显示 注意：即使我们在这里创建 Revit 对象，在这种情况下，也不需要将它们包装在 Transaction 事务中。 1234revit_xyz = Autodesk.Revit.DB.XYZ(0,0,0) # Revit XYZ# 使用XYZ对象创建点revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz)OUT = revit_xyz, revit_point 我们可以从 Python 脚本节点输出 XYZ 和 Point，但是除非将它们转换为 Dynamo 类型，否则它们将在 Dynamo 几何预览中不可见： ToPoint() ToProtoType() 123revit_xyz = Autodesk.Revit.DB.XYZ(0,0,0)revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz)OUT = revit_xyz.ToPoint(), revit_point.ToProtoType() Lines / Curves​​ 先看一下 Dynamo 类：Dynamo 有两个线型几何类。了解他们之间存在区别。 Autodesk.DesignScript.Geometry.Line 线段，具有起点和终点。 Autodesk.DesignScript.Geometry.Curve 复杂的曲面或 UV 坐标。Dynamo 的 Curve 类包含 Line 。 为了使这个示例简单，我们将在下面显示如何创建一条简单的 Dynamo 行。首先，我们将创建 Dynamo 点，然后将其用作定义直线的起点和终点。 1234dynamo_point_1 = Autodesk.DesignScript.Geometry.Point.ByCoordinates(0,0,0) # 创建起点dynamo_point_2 = Autodesk.DesignScript.Geometry.Point.ByCoordinates(10,10,0) # 创建终点dynamo_line = Autodesk.DesignScript.Geometry.Line.ByStartPointEndPoint(dynamo_point_1, dynamo_point_2) # 传入参数起点和终点创建Dynamo线段OUT = dynamo_line # 返回线段 下面尝试使用 python 脚本节点输出，并使用 ToProtoType() 将其转换为 Dynamo 几何类型，否则在 Dynamo 几何预览中将不可见。 1234revit_xyz_1 = XYZ(0,0,0)revit_xyz_2 = XYZ(10,10,0)revit_line = Line.CreateBound(revit_xyz_1, revit_xyz_2)OUT = revit_line.ToProtoType()","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.5 过滤器 FilteredElementCollector","slug":"PythonScriptPrimer/2.5 过滤器 FilteredElementCollector","date":"2021-02-09T00:08:11.000Z","updated":"2021-02-08T20:35:02.526Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.5 过滤器 FilteredElementCollector/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.5%20%E8%BF%87%E6%BB%A4%E5%99%A8%20FilteredElementCollector/","excerpt":"","text":"介绍处理模型的前提是获取到相应类型的元素。Revit 的 FilteredElementCollector 允许您使用一组自定义的过滤规则，在 Revit 文档的数据库中快速搜索元素。您可以将搜索过滤器和修饰符堆叠在一起，从而使您可以进行几乎无限次的自定义搜索。 举个简单的例子FilteredElementCollectors 将返回 Element 或 ElementIds 的列表。 快速组合在一起非常简单。例如： 12345all_furniture = FilteredElementCollector(doc) # 创建过滤器all_furniture.OfCategory(BuiltInCategory.OST_Furniture) # 过滤家具（包含：实例和类型）all_furniture.WhereElementIsNotElementType() # 过滤项目中家具实例all_furniture.ToElements() # 结果转换为Element对象列表OUT = all_furniture # 输出对象 这段代码首先创建一个新的 FilteredElementCollector 实例，该实例将 Revit 文档作为其构造函数中的参数。 第 4 行添加了一个进一步的过滤器-我们不想在返回的元素中仅包含家具族类型，而仅是实例。 在第 5 行中，我们指定我们希望 FilteredElementCollector 返回实际的 Revit 元素。 最后，第 6 行使用 OUT 从节点输出收集的元素。 也可以将上述脚本压缩为一行，如下所示： 12all_furniture = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToElements()OUT = all_furniture 这两个脚本将返回完全相同的对象，因此可以选择使用哪个版本:较长的版本还是较冗长的版本 建议使用下面这种简洁 过滤器使用指南关于如何为元素组装基本过滤器的分步指南： 知道您要过滤的内容 如果这是 Revit 类别的元素，请在 BuiltInCategory 枚举中找到等效的 BuiltInCategory 类型。 否则，如果您正在寻找特定 API 类的元素，则可以使用 .OfClass() 过滤器，并在 Class 名称中添加一个参数类别。 您是否要返回元素实例或其类型 例如，您要查找文档中的所有 TextNotes 实例还是所有 TextNoteTypes 族类型 如果需要实例，请使用 .WhereElementIsNotElementType() 过滤器 如果需要类型，请使用 .WhereElementIsElementType() 过滤器 如果您两者都想要，则不要使用过滤器 是否要返回 Revit 元素或元素的 ID 使用 .ToElements() 或 .ToElementIds() 完成您的 FilteredElementCollector 查询。 进阶筛选上面是构建基本 FilteredElementCollector 的大致指南。但是，您可以构建更多自定义过滤器： 您可以使用 ElementLevelFilter 来过滤某个级别上托管的元素，或者使用 ElementWorksetFilter 来仅过滤特定工作集上的元素。 您可以建立自定义评估规则。是否仅在指定参数值或 Height 参数大于 3000mm 的元素中寻找元素？这些都是可以轻松实现的。 此页面只是刮擦 FilteredElementCollectors 的表面。 快速过滤器-QuickFilters ElementCategoryFilter ：与输入类别 ID 匹配的元素； 快捷方式：OfCategory ElementClassFilter：与输入运行时类匹配的元素； 快捷方式：OfClass ElementIsElementTypeFilter：是“元素类型”（符号）的元素； 快捷方式：WhereElementIsElementType / WhereElementIsNotElementType ElementOwnerViewFilter：特定于视图的元素； 快捷方式：OwnedByView / WhereElementIsViewIndependent ElementDesignOptionFilter：特定设计选项中的元素； 快捷方式：ContainedInDesignOption ElementIsCurveDrivenFilter：曲线驱动的元素； 快捷方式：WhereElementIsCurveDriven ElementStructuralTypeFilter：匹配给定结构类型的元素 FamilySymbolFilter：特定家庭的符号 ExclusionFilter：除输入到过滤器中的元素 ID 之外的所有元素 BoundingBoxIntersectsFilter：具有与给定轮廓相交的边界框的元素 BoundingBoxIsInsideFilter：在给定轮廓内具有边界框的元素 BoundingBoxContainsPointFilter：具有包含给定点的边界框的元素","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.3 了解 Doc, UIDoc, App, UIApp","slug":"PythonScriptPrimer/2.3 了解 Doc, UIDoc, App, UIApp","date":"2021-02-09T00:08:10.000Z","updated":"2021-02-08T20:33:36.090Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.3 了解 Doc, UIDoc, App, UIApp/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.3%20%E4%BA%86%E8%A7%A3%20Doc,%20UIDoc,%20App,%20UIApp/","excerpt":"","text":"样板代码正如在样板代码一章中所见，Revit 样板代码通常需要设置 Revit 应用程序和文档 doc，uidoc，app，uiapp的句柄。 但是为什么呢？ Application and Document一开始，API 的这一部分似乎有些混乱。问题比比皆是：Revit 不能仅算出我所处的文档（即模型）吗？为什么我有一个 Document 和一个 UIDocument？为什么要引用应用程序-应用程序不是 Revit 吗？ 这些是很好的问题。幸运的是，Revit 的 API 指南为我们提供了一些答案： Revit Platform API 中的顶级对象是应用程序和文档。这些由类 Application，UIApplication，Document 和 UIDocument 表示。 应用程序对象引用一个单独的 Revit 会话 提供对文档，选项以及其他应用程序范围的数据和设置的访问。 Autodesk.Revit.UI.UIApplication 提供对应用程序的 UI 级别界面的访问，包括将 RibbonPanels 添加到用户界面的能力，以及在用户界面中获取活动文档的能力。 Autodesk.Revit.ApplicationServices.Application 提供对所有其他应用程序级别属性的访问。 该文档对象是代表建筑模型的单个 Revit 项目文件 Revit 可以打开多个项目，并为一个项目提供多个视图。 Autodesk.Revit.UI.UIDocument 提供对文档的 UI 级别界面的访问，例如选择内容以及提示用户进行选择和选择点的功能 Autodesk.Revit.DB.Document 提供对所有其他文档级别属性的访问 总结 一次可以打开多个 Revit 文档（包括.rfa 文件），因此需要指定要定位的文档。 您还可以具有多个 Revit 应用程序的运行实例，因此您需要指定要定位的应用程序。 Document / UIDocument 和 Application / UIApplication 拆分是由 API 设计人员决定的。UI 类通常引用用户界面元素或需要交互的元素（例如提示用户在主 Revit 窗口中选择元素）。 主要要知道的是，我们的样板代码中的 doc，uidoc，app 和 uiapp 句柄对于涉及编辑 Revit 文档的许多操作都是必不可少的。例如，要删除某些内容？您需要参考要从中删除内容的文档！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.4 展开Revit元素","slug":"PythonScriptPrimer/2.4 展开Revit元素","date":"2021-02-09T00:08:10.000Z","updated":"2021-02-08T20:34:04.771Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.4 展开Revit元素/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.4%20%E5%B1%95%E5%BC%80Revit%E5%85%83%E7%B4%A0/","excerpt":"","text":"About Unwrapping展开元素？现在有一些奇怪的术语！简而言之：引入节点的 Revit 元素在使用前需要先’unwrapped’。 但是为了了解所有含义，我们需要对 Dynamo 的最初开发方式有一点了解。 回顾历史 🏰Dynamo 最初被认为是 Ian Keough 的开源爱好项目。Dynamo 最初仅用于与 Revit 集成，但它还需要 Revit API 本身不提供的扩展功能，例如可视化抽象几何。 围绕此问题的方法是，Ian 的新应用程序使用其自己的等效类型实质上封装 Revit API 中的大约 1700 个类-这些类型的功能可以根据 Dynamo 的要求进行构建。 因此，Revit 的类与 Dynamo 的等效类之间存在细微且不可察觉的差异（此类类称为“包装器类”）。 如果我们检查 Revit 对象的类名称及其等效的 Dynamo 对象，则可以看到。例如，让我们看一下 Level 对象： 在 Revit 的 API 中，Level 类的完全限定名称为：Autodesk.Revit.DB.Level 在 Dynamo 中，Level 类的完全限定名称为：Revit.Elements.Level 编码 ToRevitType通常，Dynamo 会完成这两个工作之间的所有工作，即不可见地包裹和展开包裹元素。除了编写代码时，我们不必担心具体的技术细节。 在编写 IronPython 脚本时，我们可能会将元素作为输入提供给 Python 脚本节点。在我们解开它们之前，这些元素仍将是 Dynamo 的”包装”类型。在我们这样做之前，Revit 的类型和 Dynamo 的等效类型不能很好地配合使用。 展开元素非常简单，就像这样： 123# 使用 UnwrapElement() 方法# 将 Dynamo 元素类型转换为 Revit 元素类型revitElements = UnwrapElement(IN[0]) 注意： 未能使用 UnwrapElement 本身不会引发错误，但是在读取属性或使用包装类型的方法时会出错。 无需总是解开元素 **UnwrapElement()**，仅当它们从 Python Script 节点外部传入时使用即可。 例如，当使用 FilteredElementCollector 收集元素时，我们将绕过 Dynamo 并直接与 Revit 的 API 获取数据，该 API 将 Revit 的本身类型返回给我们，所以不需要解开元素！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.2 如何阅读Revit的API文档","slug":"PythonScriptPrimer/2.2 如何阅读Revit的API文档","date":"2021-02-09T00:08:09.000Z","updated":"2021-02-08T20:33:14.134Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.2 如何阅读Revit的API文档/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.2%20%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBRevit%E7%9A%84API%E6%96%87%E6%A1%A3/","excerpt":"","text":"使用 APIDocs.Co由于该网站对于希望熟悉 Revit API 的人来说是非常宝贵的资源，因此我们提供了使用该网站的简要指南。 典型的工作流程将涉及确保已为要使用的产品选择合适版本的 API（在左窗格中），然后在 API 文档中搜索您关注的相关主题。例如，如果要了解有关 FamilyInstance 类的更多信息，只需在搜索栏中搜索它，然后从自动完成选项中选择它即可。然后，有关此类的详细信息将显示在右侧的详细信息窗格中： 这是您正在查看的页面的名称。Revit API 有超过 22,000 页，但其中的大部分都是不经常使用的！ 这个 &lt;&gt; 按钮将在几个流行的 Github 存储库中搜索有关该类的任何代码示例。 Members 将带您到显示该类的所有方法，属性，接口或构造函数的整个页面。 面向对象编程Members: 类的成员页面只是将其所有方法，属性等收集在一个页面上。如果不确定某个类是否具有特定功能，这将非常有用。 Methods: 类方法是它可以运行的功能。可以将它们视为动词 do something 的实例可以做什么。例如，FamilyInstance 类型的对象具有 flipHand() 方法，可让您翻转其处理方式。 12# 可是使用 flipHand 翻转 my_family_instance 实例对象my_family_instance.flipHand() 注意：对 Revit 文档所做的任何更改都必须在开始事务 Transaction . Properties: 属性更像是类的”形容词”，可帮助您了解有关该类特定对象（即实例）的更多状态。例如，FamilyInstance 类具有一个 HandFlipped 属性，可以查询该属性的值，反应了该特定实例的是否已翻转。 12# 这将返回True或False，具体取决于对象是否翻转is_it_handflipped = my_family_instance.HandFlipped Constructors: API 中的构造函数实际上是在告诉您如何创建类的实例。例如，XYZ 类用于在 Revit 中定义点。我们可以使用其构造函数来创建一个新的，如下所示： 12# 创建一个新的点my_point = XYZ(0,0,0) 注意：与 Dynamo 不同的是 Revit 创建的几何对象是不可见的 Enumerations: 这些也称为枚举，它们是硬编码的列表，通常不打算更改并且将选择限制为一组选项。交通信号灯状态的枚举应类似于： Red Yellow Green 因此，用户创建的任何交通信号灯对象都需要将其交通信号灯状态设置为软件供应商定义的预写状态之一。您可以选择枚举值，如下所示： 12# enum枚举中的一种预定义状态traffic_light_value = TrafficLightState.Green Revit API 中的一些关键的枚举类型： BuiltInCategory : 类型 BuiltInParameter : 参数 DisplayUnitType : 单位","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.1 Revit API简介","slug":"PythonScriptPrimer/2.1 Revit API简介","date":"2021-02-09T00:08:08.000Z","updated":"2021-02-08T20:32:46.675Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.1 Revit API简介/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.1%20Revit%20API%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Revit API 简介Revit 自 2000 年代初以来就具有可访问的 API，可用于驱动该软件的几乎每个方面。由于 Revit 应用程序非常复杂，并且满足多专业功能需求（建筑结构，MEP 等），因此它的 API 非常大且需要一段时间才能直观地理解也就不足为奇了。 我经常发现最容易想到 Revit 主要是一个数据库，我们在使用该应用程序时会不断对其进行更新。数据库存储我们的内容（其元素 ID，类别，位置等）。在此之上是 GUI，它表示 3D 空间中元素的几何形状/位置，并让我们与元素进行交互。 最后，还有一点网络魔术可以使我们跨局域网/ Revit Server / BIM360 设置工作共享。 以这种方式思考 Revit 与大多数用户体验该软件的方式完全不同。实际上，当我们针对 Revit 的 API 编写脚本时，我们只是对数据库进行了一系列调用，受该 API 规则的约束。 版本和历史对于 Revit 的每个发行版和子发行版，Autodesk Revit 团队都会对其 API 进行较小的更新或添加。这些更改主要与软件本身的功能更改有关。 Revit SDK &amp; API 文档软件开发套件（SDK）是软件供应商向开发人员分发有关其 API 的信息的一种常用方法。可以在找到官方的 Revit SDK 。 官方 SDK 点击下载 所有 API 都需要技术文档，因此程序员可以选择它们并学习如何使用代码来驱动应用程序。Revit SDK 包含.chm 文件中的官方 API 文档以及代码示例（用 Visual Basic 和 C＃编写）。 但是，本指南建议阅读 APIDocs.co 网站上的 Revit API ，这比打开 .chm 文件方便许多。 APIDocs.co","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.3 基本：输入和输出","slug":"PythonScriptPrimer/1.3 基本：输入和输出","date":"2021-02-08T12:05:00.000Z","updated":"2021-02-08T12:14:10.913Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.3 基本：输入和输出/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.3%20%E5%9F%BA%E6%9C%AC%EF%BC%9A%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/","excerpt":"输入和输出IN 和 OUT 是 Dynamo 的 Python 节点中的重要关键字。IN 关键字告诉节点引用通过其输入发送到节点的任何数据。 注意：后面所有的程序代码均运行在模板文件代码块内","text":"输入和输出IN 和 OUT 是 Dynamo 的 Python 节点中的重要关键字。IN 关键字告诉节点引用通过其输入发送到节点的任何数据。 注意：后面所有的程序代码均运行在模板文件代码块内 通过它们的索引可以访问各种输入，例如下面的 list_of_numbers： 12345678input_list_of_numbers = IN[0] # 获取外部节点输入output_list_of_numbers = [] # 创建空列表作为输出的内容for number in input_list_of_numbers: new_number = number + 1 output_list_of_numbers.append(new_number)OUT = output_list_of_numbers # 输出新的列表内容（传入的值每个数字均进行 +1 操作） 在此示例中，我们最初为输出创建一个空列表。我们遍历输入列表中的每个数字，并将其进行 +1 操作后添加到我们创建的输出列表中。最后，通过 OUT 关键字输出列表。 实际上，它看起来像这样： 输入和输出的类型Dynamo 节点可以将任何种类的数据作为输入，并可以输出任何种类的数据作为输出。 它能够将元素（例如 Revit 元素），抽象数字，字符串，Dynamo 几何图形以及其他所有内容作为输入。 但是，将 Revit 元素输入到 Python 节点时有一个警告。 Revit 元素需要进行转换类型后，才能通过 API 进行访问。 了解 Dynamo Revit 数据类型转换","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.2 样板代码设置","slug":"PythonScriptPrimer/1.2 样板代码设置","date":"2021-02-08T12:00:50.000Z","updated":"2021-02-08T12:12:54.275Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.2 样板代码设置/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.2%20%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE/","excerpt":"样板代码设置复制代码文件到本地保存为 RevitApi.py","text":"样板代码设置复制代码文件到本地保存为 RevitApi.py 1234567891011121314151617181920212223242526272829303132333435import clrimport syssys.path.append(&#x27;C:\\Program Files (x86)\\IronPython 2.7\\Lib&#x27;)import Systemfrom System import Arrayfrom System.Collections.Generic import *clr.AddReference(&#x27;ProtoGeometry&#x27;)from Autodesk.DesignScript.Geometry import *clr.AddReference(&quot;RevitNodes&quot;)import Revitclr.ImportExtensions(Revit.Elements)clr.ImportExtensions(Revit.GeometryConversion)clr.AddReference(&quot;RevitServices&quot;)import RevitServicesfrom RevitServices.Persistence import DocumentManagerfrom RevitServices.Transactions import TransactionManagerclr.AddReference(&quot;RevitAPI&quot;)clr.AddReference(&quot;RevitAPIUI&quot;)import Autodeskfrom Autodesk.Revit.DB import *from Autodesk.Revit.UI import *doc = DocumentManager.Instance.CurrentDBDocumentuiapp = DocumentManager.Instance.CurrentUIApplicationapp = uiapp.Applicationuidoc = uiapp.ActiveUIDocumentTransactionManager.Instance.EnsureInTransaction(doc) # 事务开始####### 逻辑代码 ########TransactionManager.Instance.TransactionTaskDone() # 事务结束OUT = doc Python Script 样板文件Dynamo 2.0 开始,引入 Python 脚本模板。默认应用变量会自动添加到 Python Script 节点 复制文件RevitBoilerplate.py到位置位于 Dynamo 安装的 APPDATA 位置。 路径：%appdata%\\Dynamo\\Dynamo Revit\\{version}\\ 修改文件DynamoSettings.xml中的 PythonTemplateFilePath 内容 123&lt;PythonTemplateFilePath&gt; C:\\Users\\&#123;USERNAME&#125;\\AppData\\Roaming\\Dynamo\\Dynamo Revit\\&#123;version&#125;\\RevitBoilerplate.py&lt;/PythonTemplateFilePath&gt; 完成上面的设置之后。就可以使用 Dynamo 愉快编写 python 脚本操控 Revit 软件！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.1 Dynamo's Python编辑器","slug":"PythonScriptPrimer/1.1 Dynamo's Python编辑器","date":"2021-02-08T11:49:51.000Z","updated":"2021-02-08T12:12:41.712Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.1 Dynamo's Python编辑器/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.1%20Dynamo's%20Python%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"Dynamo 的 Python 脚本编辑器Python 脚本节点随 Dynamo 一起安装，并且在许多方面，它与任何其他节点一样：可以放置在工作空间中，重命名并可以接受任意数量的输入。","text":"Dynamo 的 Python 脚本编辑器Python 脚本节点随 Dynamo 一起安装，并且在许多方面，它与任何其他节点一样：可以放置在工作空间中，重命名并可以接受任意数量的输入。 但是，与其他节点不同，如果右键单击并选择 Edit.. 则会出现一个脚本编辑窗口(双击节点)，如下所示： 在此窗口中，您可以编写 IronPython 脚本，这些脚本将作为 Dynamo 定义的一部分直接执行。要保存脚本，请单击 保存更改 按钮，然后保存其中的 Dynamo 定义。否则，请单击“取消”按钮以放弃所做的任何更改。 如何编写程序使用 Dynamo 编写 Python 代码！后面会学习设置样板代码，引用 Revit Api。 dynamo 手册","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]}],"categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]}