{"meta":{"title":"龙|Engineer|BIMer","subtitle":"轨迹","description":"记录学习轨迹","author":"龙","url":"https://zedmoster.github.io","root":"/"},"pages":[{"title":"about","date":"2021-02-07T16:00:00.000Z","updated":"2021-02-08T20:03:27.623Z","comments":true,"path":"about/index.html","permalink":"https://zedmoster.github.io/about/index.html","excerpt":"","text":"专业：土木工程（2017） 职业：软件工程师、建筑设计师 学习：BIM、python、C#"},{"title":"categories","date":"2021-02-08T08:34:08.000Z","updated":"2021-02-08T11:26:23.807Z","comments":true,"path":"categories/index.html","permalink":"https://zedmoster.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2021-02-08T08:34:16.000Z","updated":"2021-02-08T11:32:16.602Z","comments":true,"path":"search/index.html","permalink":"https://zedmoster.github.io/search/index.html","excerpt":"","text":""},{"title":"tags","date":"2021-02-08T08:33:55.000Z","updated":"2021-02-08T11:26:16.317Z","comments":true,"path":"tags/index.html","permalink":"https://zedmoster.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"十分钟入门 Pandas","slug":"0.learn_pandas/Pandas 入门手册","date":"2021-02-23T12:00:02.000Z","updated":"2021-02-24T11:21:19.060Z","comments":true,"path":"2021/02/23/0.learn_pandas/Pandas 入门手册/","link":"","permalink":"https://zedmoster.github.io/2021/02/23/0.learn_pandas/Pandas%20%E5%85%A5%E9%97%A8%E6%89%8B%E5%86%8C/","excerpt":"十分钟(删掉小时)入门 Pandas 导入 Pandas1import pandas as pd","text":"十分钟(删掉小时)入门 Pandas 导入 Pandas1import pandas as pd ——————–官方文档——————– 生成对象创建 一维数据 对象123456789101112131415161718192021import pandas as pdd1 = pd.Series([1,2,3,4,5])d2 = pd.Series([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;,&quot;e&quot;])# df = pd.DataFrame(&#123;&quot;A&quot;:d1, &quot;B&quot;:d2&#125;)&#x27;&#x27;&#x27;0 11 22 33 44 5dtype: int640 a1 b2 c3 d4 edtype: object&#x27;&#x27;&#x27; 创建 二维数据 对象12345678910111213141516import pandas as pdimport numpy as np# 创建一个6行3列的随机数据df = pd.DataFrame(np.random.randn(6,3), index = [i for i in range(6)], columns = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])&#x27;&#x27;&#x27; A B C0 0.124665 1.354623 -0.7011151 0.793852 -0.378799 0.5026192 -0.343502 -0.153304 1.0085493 1.047741 0.434839 -0.4613874 -2.024051 0.270098 0.7504145 0.756700 0.265707 -0.531845&#x27;&#x27;&#x27; 查看数据查看 DataFrame 头部与尾部数据123456789101112131415161718192021222324252627print(df) # 查看全部数据print(&quot;=&quot;*30) # 分隔print(df.head()) # 查看头部数据print(&quot;=&quot;*30) # 分隔print(df.tail(3)) # 查看尾部数据&#x27;&#x27;&#x27; A B C0 0.162626 0.743775 -0.0435581 0.284162 -0.957022 1.6185782 0.027395 -0.073792 1.7304173 0.030660 2.162612 1.0879334 -0.840563 0.011711 -1.5827715 -1.129669 -1.069730 -1.274151============================== A B C0 0.162626 0.743775 -0.0435581 0.284162 -0.957022 1.6185782 0.027395 -0.073792 1.7304173 0.030660 2.162612 1.0879334 -0.840563 0.011711 -1.582771============================== A B C3 0.030660 2.162612 1.0879334 -0.840563 0.011711 -1.5827715 -1.129669 -1.069730 -1.274151&#x27;&#x27;&#x27; 查看 索引与列名1234567print(df.index) # 查看索引print(df.columns) # 查看列名&#x27;&#x27;&#x27;Int64Index([0, 1, 2, 3, 4, 5], dtype=&#x27;int64&#x27;)Index([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;], dtype=&#x27;object&#x27;)&#x27;&#x27;&#x27; 快速查看数据的 统计摘要12345678910111213print(df.describe()) # 数据的统计摘要&#x27;&#x27;&#x27; A B Ccount 10.000000 10.000000 10.000000mean -0.134164 0.066692 -0.623249std 0.972375 1.050455 0.807784min -1.643474 -1.460358 -1.86089325% -0.709000 -0.225956 -1.22393750% -0.300770 -0.065260 -0.56080175% 0.403706 0.283554 -0.120445max 1.663865 2.175142 0.768465&#x27;&#x27;&#x27; 转置数据123456789101112131415161718print(df)print(&quot;=&quot;*30)print(df.T)&#x27;&#x27;&#x27; A B C0 1.090855 -1.072805 0.1845831 -0.868626 0.318964 -0.1216292 -0.791555 0.260809 -0.7103103 -1.929772 -0.051195 -0.7283304 2.554131 0.498501 2.1333605 -0.823963 -1.090279 -0.522702============================== 0 1 2 3 4 5A 1.090855 -0.868626 -0.791555 -1.929772 2.554131 -0.823963B -1.072805 0.318964 0.260809 -0.051195 0.498501 -1.090279C 0.184583 -0.121629 -0.710310 -0.728330 2.133360 -0.522702&#x27;&#x27;&#x27; 按轴排序12345678910111213141516171819202122print(df)print(&quot;=&quot;*30)# axis: 0 按行 1 按列 ascending: False 不改变源数据 True 改变源数据print(df.sort_index(axis=1, ascending=False))&#x27;&#x27;&#x27; A B C0 2.155336 -0.434339 -0.0903911 0.890209 0.129525 1.1797822 1.220253 1.303012 -0.6984333 -0.804471 0.224135 -0.7035214 -1.253433 -1.146150 -0.7351215 -0.670339 -1.742963 1.990105============================== C B A0 -0.090391 -0.434339 2.1553361 1.179782 0.129525 0.8902092 -0.698433 1.303012 1.2202533 -0.703521 0.224135 -0.8044714 -0.735121 -1.146150 -1.2534335 1.990105 -1.742963 -0.670339&#x27;&#x27;&#x27; 按值排序123456789101112131415161718192021print(df)print(&quot;=&quot;*30)print(df.sort_values(by=&quot;A&quot;)) # 按列名所对应的值&#x27;&#x27;&#x27; A B C0 -0.949729 0.405278 0.5387121 -0.064786 1.980200 -0.4870462 -0.399375 2.208867 -0.2202383 2.146529 -1.066433 -1.1768794 -0.898716 -2.105429 -0.5583205 2.259551 0.161280 -0.290100============================== A B C0 -0.949729 0.405278 0.5387124 -0.898716 -2.105429 -0.5583202 -0.399375 2.208867 -0.2202381 -0.064786 1.980200 -0.4870463 2.146529 -1.066433 -1.1768795 2.259551 0.161280 -0.290100&#x27;&#x27;&#x27; 选择数据推荐使用：优化过的 Pandas 数据访问方法：.at \\ .iat \\ .loc \\ .iloc 获取数据获取单列，产生 Series。与 df.A 等效 12345678910111213141516171819202122print(df)print(&quot;=&quot;*30)print(df[&quot;A&quot;])# print(df.A)&#x27;&#x27;&#x27; A B C0 -3.889165 0.058995 -0.1314901 0.214254 0.753761 -0.4065892 -0.321746 0.337223 1.2094533 -0.096389 0.656442 1.0167074 -0.496134 -0.798966 0.4256545 0.278245 -0.705807 0.986345==============================0 -3.8891651 0.2142542 -0.3217463 -0.0963894 -0.4961345 0.278245Name: A, dtype: float64&#x27;&#x27;&#x27; 用[ ] 切片行 1234567891011121314151617print(df)print(&quot;=&quot;*30)print(df[2:4]) # 第2行至第4行，左闭右开&#x27;&#x27;&#x27; A B C0 -0.364004 0.148870 -0.3306801 -0.572930 -1.423234 1.9843262 -1.996496 0.120526 -2.8299683 0.406163 0.824016 0.9579994 -1.215831 -1.298448 0.9478105 -0.511757 1.180600 0.913132============================== A B C2 -1.996496 0.120526 -2.8299683 0.406163 0.824016 0.957999&#x27;&#x27;&#x27; 按标签选择用标签提取一行数据 123456789101112131415161718print(df)print(&quot;=&quot;*30)print(df.loc[df.index[0]]) # 索引为提取行数的索引&#x27;&#x27;&#x27; A B C0 0.339023 0.661502 0.8249861 0.619245 0.474774 -0.0556002 1.015228 -0.355425 -0.4440533 -0.424160 -0.761022 0.0240264 0.932760 0.666029 -0.2037205 -1.002828 0.209472 -1.442866==============================A 0.339023B 0.661502C 0.824986Name: 0, dtype: float64&#x27;&#x27;&#x27; 用标签选择多列数据 123456789101112131415161718192021print(df)print(&quot;=&quot;*30)print(df.loc[:, [&#x27;A&#x27;, &#x27;B&#x27;]]) # : 提取所有的行 列名为 A B 的列&#x27;&#x27;&#x27; A B C0 -0.060654 -0.813041 -1.0739701 -0.851160 1.043976 0.1941832 0.264642 -0.331834 -0.1937183 0.803170 2.130145 0.2447534 1.028380 1.088563 -1.1762005 0.824463 0.115124 -0.603710============================== A B0 -0.060654 -0.8130411 -0.851160 1.0439762 0.264642 -0.3318343 0.803170 2.1301454 1.028380 1.0885635 0.824463 0.115124&#x27;&#x27;&#x27; 用标签切片，包含行与列结束点 1234567891011121314151617print(df)print(&quot;=&quot;*30)print(df.loc[2:4, [&#x27;A&#x27;, &#x27;B&#x27;]]) # : 提取2-4行 列名为 A B 的列&#x27;&#x27;&#x27; A B C0 1.341213 1.374567 0.8961751 -1.432347 -1.498885 0.8972292 -0.169359 -0.079813 0.7789383 0.393801 0.451041 -0.6896134 -1.103175 1.342899 -0.4029915 0.742279 -0.119841 1.114146============================== A B2 -0.169359 -0.0798133 0.393801 0.451041&#x27;&#x27;&#x27; 提取标量值 12345678910111213141516print(df)print(&quot;=&quot;*30)print(df.loc[0, &#x27;A&#x27;]) # 按行列名提取值# print(df.at[0, &#x27;A&#x27;])&#x27;&#x27;&#x27; A B C0 1.046345 1.010179 -0.3528251 -0.409664 1.269217 0.3934182 0.059705 -1.613766 0.5601003 -1.070312 -1.936424 1.0925464 0.237776 1.716479 0.1887435 -0.321937 1.261209 -0.169163==============================1.04634487598175&#x27;&#x27;&#x27; 按位置选择用整数位置选择 123456789101112131415161718print(df)print(&quot;=&quot;*30)print(df.iloc[1]) # 行位置进行选择&#x27;&#x27;&#x27; A B C0 0.872330 0.687903 0.1590911 0.829951 -1.186121 0.9557212 -0.641111 1.725069 0.4397623 -0.353691 1.285310 -1.2071744 -2.075890 -0.105968 0.0724715 1.347517 -0.675439 1.083256==============================A 0.829951B -1.186121C 0.955721Name: 1, dtype: float64&#x27;&#x27;&#x27; 类似 NumPy / Python，用整数切片 1234567891011121314151617print(df)print(&quot;=&quot;*30)print(df.iloc[3:5, 0:2]) # 切片选择&#x27;&#x27;&#x27; A B C0 1.326371 0.416501 -0.8483631 -0.112608 -0.330069 -1.7589262 -0.783527 1.840435 -1.8792463 -1.322841 0.379742 0.8615234 -0.650409 2.086843 0.7818315 2.226036 -1.644519 -0.401621============================== A B3 -1.322841 0.3797424 -0.650409 2.086843&#x27;&#x27;&#x27; 类似 NumPy / Python，用整数列表按位置切片 123456789101112131415161718print(df)print(&quot;=&quot;*30)print(df.iloc[[1, 2, 4], [0, 2]]) # 按位置&#x27;&#x27;&#x27; A B C0 -0.097128 0.610125 -2.3528951 0.649887 0.805659 0.0905652 2.301369 0.795259 -0.4136433 0.492440 1.282051 -1.3985034 -0.470341 0.998427 -0.0819935 -0.959278 -0.810422 -1.229398============================== A C1 0.649887 0.0905652 2.301369 -0.4136434 -0.470341 -0.081993&#x27;&#x27;&#x27; 整行切片 1234567891011121314151617print(df)print(&quot;=&quot;*30)print(df.iloc[1:3, :]) # 整行切片&#x27;&#x27;&#x27; A B C0 -0.153717 -0.106818 -0.1724071 -0.283473 -0.683112 -0.7504592 -1.485220 0.992581 -0.0218523 0.245505 -1.018984 0.1657504 0.777344 -0.746399 0.8709305 -0.984809 2.206306 0.940896============================== A B C1 -0.283473 -0.683112 -0.7504592 -1.485220 0.992581 -0.021852&#x27;&#x27;&#x27; 整列切片 123456789101112131415161718192021print(df)print(&quot;=&quot;*30)print(df.iloc[:, 1:3]) # 整列切片&#x27;&#x27;&#x27; A B C0 -1.993272 1.161443 0.3528101 -0.377859 -1.122316 -0.9529712 0.392742 0.366656 -1.7197203 -1.132892 1.721778 1.4138764 0.846929 -0.397196 0.7227705 -1.910569 0.215684 1.384120============================== B C0 1.161443 0.3528101 -1.122316 -0.9529712 0.366656 -1.7197203 1.721778 1.4138764 -0.397196 0.7227705 0.215684 1.384120&#x27;&#x27;&#x27; 提取值 12345678910111213141516print(df)print(&quot;=&quot;*30)print(df.iloc[1, 1]) # 提取指定行列位置单元格的值# print(df.iat[1,1])&#x27;&#x27;&#x27; A B C0 0.075752 0.842907 -2.9692431 -0.253084 0.069218 1.4216682 0.671382 0.187895 -0.0627803 -0.544736 -2.225326 -1.9440384 -0.542584 -0.391144 0.1458395 0.615728 -0.719422 -0.087461==============================0.06921757818689403&#x27;&#x27;&#x27; 布尔索引用单列的值选择数据 1234567891011121314151617print(df)print(&quot;=&quot;*30)print(df[df.A &gt; 0])&#x27;&#x27;&#x27; A B C0 0.225120 0.312929 1.1792281 -0.357687 1.709017 1.6232912 0.278348 -1.132671 1.2076913 -2.523049 0.227406 -0.3609944 -0.157327 -0.292324 -0.1978615 -0.708942 1.225583 0.281490============================== A B C0 0.225120 0.312929 1.1792282 0.278348 -1.132671 1.207691&#x27;&#x27;&#x27; 选择 DataFrame 里满足条件的值 123456789101112131415161718192021print(df)print(&quot;=&quot;*30)print(df[df &gt; 0])&#x27;&#x27;&#x27; A B C0 0.456279 -1.338378 -0.1169221 -1.835649 1.514987 -0.8621782 0.515765 1.064303 0.7173283 1.485883 1.320943 0.9772024 1.033369 -0.980634 -1.7029965 0.385172 0.056046 0.784007============================== A B C0 0.456279 NaN NaN1 NaN 1.514987 NaN2 0.515765 1.064303 0.7173283 1.485883 1.320943 0.9772024 1.033369 NaN NaN5 0.385172 0.056046 0.784007&#x27;&#x27;&#x27; 用 isin() 筛选 1234567891011121314151617181920# 添加辅助列df[&#x27;D&#x27;] = [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;four&#x27;, &#x27;three&#x27;]print(df)print(&quot;=&quot;*30)print(df[df[&#x27;D&#x27;].isin([&#x27;two&#x27;, &#x27;four&#x27;])])&#x27;&#x27;&#x27; A B C D0 -0.282657 -1.393703 0.875241 one1 -0.276764 -1.399960 -0.028655 one2 1.611027 1.376589 0.043859 two3 -0.360664 -0.490467 0.489825 three4 0.218109 1.323599 -0.541452 four5 0.307106 0.358602 -0.751541 three============================== A B C D2 1.611027 1.376589 0.043859 two4 0.218109 1.323599 -0.541452 four&#x27;&#x27;&#x27; 赋值用索引自动对齐新增列的数据 1234567891011121314151617181920212223242526# 增列的数据s = pd.Series([1, 2, 3, 4, 5, 6], index= [i for i in range(6)])# s = pd.Series([1, 2, 3, 4], index= [i for i in range(4)])print(df)print(&quot;=&quot;*30)df[&quot;D&quot;] = sprint(df)&#x27;&#x27;&#x27; A B C0 1.541004 -0.621590 0.5428951 0.685524 1.112586 -0.2247012 -0.531432 1.739056 -1.1605243 0.220122 -0.507556 0.2898014 0.791843 -0.278992 -1.6625835 0.494893 -1.428766 -1.913229============================== A B C D0 1.541004 -0.621590 0.542895 11 0.685524 1.112586 -0.224701 22 -0.531432 1.739056 -1.160524 33 0.220122 -0.507556 0.289801 44 0.791843 -0.278992 -1.662583 55 0.494893 -1.428766 -1.913229 6&#x27;&#x27;&#x27; 按标签赋值 12345678910111213141516171819202122print(df)print(&quot;=&quot;*30)df.at[df.index[0], &quot;A&quot;] = 0print(df)&#x27;&#x27;&#x27; A B C0 -0.896498 -1.134660 -1.7011851 -0.495562 -0.039068 -0.1366142 0.156827 0.028074 0.0511093 1.300580 -0.404301 0.5577944 0.648387 -0.110362 0.6827235 0.627710 1.071018 -0.375658============================== A B C0 0.000000 -1.134660 -1.7011851 -0.495562 -0.039068 -0.1366142 0.156827 0.028074 0.0511093 1.300580 -0.404301 0.5577944 0.648387 -0.110362 0.6827235 0.627710 1.071018 -0.375658&#x27;&#x27;&#x27; 按位置赋值 12345678910111213141516171819202122print(df)print(&quot;=&quot;*30)df.iat[0,0] = 0print(df)&#x27;&#x27;&#x27; A B C0 -0.229924 -1.556863 1.3829651 1.078071 -1.616441 -0.9061432 -0.998971 0.095389 0.3077993 -1.363223 1.481546 -0.6409174 0.797193 -1.737114 0.5296795 0.293870 0.813873 -1.296403============================== A B C0 0.000000 -1.556863 1.3829651 1.078071 -1.616441 -0.9061432 -0.998971 0.095389 0.3077993 -1.363223 1.481546 -0.6409174 0.797193 -1.737114 0.5296795 0.293870 0.813873 -1.296403&#x27;&#x27;&#x27; 用 where 条件赋值 12345678910111213141516171819202122print(df)print(&quot;=&quot;*30)df[df &lt; 0] = -dfprint(df)&#x27;&#x27;&#x27; A B C0 0.283596 0.338517 -0.0512211 1.504277 -0.642568 -2.0944422 -1.054536 0.605670 0.3451823 -0.316435 -0.360860 -0.6232694 0.893348 -0.417538 -1.2498965 1.234152 0.341326 1.208369============================== A B C0 0.283596 0.338517 0.0512211 1.504277 0.642568 2.0944422 1.054536 0.605670 0.3451823 0.316435 0.360860 0.6232694 0.893348 0.417538 1.2498965 1.234152 0.341326 1.208369&#x27;&#x27;&#x27; 缺失值Pandas 主要用 np.nan 表示缺失数据。 删除所有含缺失值的行123456789101112131415161718192021s = pd.Series([1, 2, 3], index= [i for i in range(1,4)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.dropna(how=&#x27;any&#x27;))&#x27;&#x27;&#x27; A B C D0 -0.543853 1.078289 1.605213 NaN1 0.153537 -0.710202 0.759139 1.02 -1.274189 -1.197363 -0.827345 2.03 -0.842268 -0.461013 -0.506485 3.04 1.244591 0.628373 0.222035 NaN5 -1.022085 2.114092 -1.020721 NaN============================== A B C D1 0.153537 -0.710202 0.759139 1.02 -1.274189 -1.197363 -0.827345 2.03 -0.842268 -0.461013 -0.506485 3.0&#x27;&#x27;&#x27; 填充缺失值123456789101112131415161718192021222324s = pd.Series([1, 2, 3], index= [i for i in range(1,4)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.fillna(value=0))&#x27;&#x27;&#x27; A B C D0 0.320348 -0.155423 -1.706578 NaN1 -1.117155 -1.388033 -0.112940 1.02 1.472523 -1.621894 0.281751 2.03 -1.273164 -0.487470 -0.156216 3.04 0.323109 1.527510 0.648772 NaN5 -0.297837 -2.281177 1.050784 NaN============================== A B C D0 0.320348 -0.155423 -1.706578 0.01 -1.117155 -1.388033 -0.112940 1.02 1.472523 -1.621894 0.281751 2.03 -1.273164 -0.487470 -0.156216 3.04 0.323109 1.527510 0.648772 0.05 -0.297837 -2.281177 1.050784 0.0&#x27;&#x27;&#x27; 提取 NaN 值的布尔掩码123456789101112131415161718192021222324s = pd.Series([1, 2, 3], index= [i for i in range(1,4)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.isna())&#x27;&#x27;&#x27; A B C D0 0.462171 -0.212011 1.621004 NaN1 -2.031842 1.020010 -0.346799 1.02 0.772598 -1.037917 0.252420 2.03 -0.995666 -0.464408 -0.319256 3.04 -1.564766 0.503919 -0.021231 NaN5 0.598078 -0.400159 -0.112247 NaN============================== A B C D0 False False False True1 False False False False2 False False False False3 False False False False4 False False False True5 False False False True&#x27;&#x27;&#x27; 运算统计一般情况下，运算时排除缺失值。描述性统计 12345678910111213141516171819202122s = pd.Series([1, 2, 3], index= [i for i in range(1,4)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.mean())&#x27;&#x27;&#x27; A B C D0 -1.703692 -0.575941 0.628585 NaN1 0.916258 0.854553 0.380848 1.02 0.492740 -0.523946 1.288998 2.03 0.533275 -0.607054 -2.210509 3.04 -1.286734 1.610702 0.775895 NaN5 1.206607 -1.991650 2.387589 NaN==============================A 0.026409B -0.205556C 0.541901D 2.000000dtype: float64&#x27;&#x27;&#x27; 在另一个轴(即，行)上执行同样的操作 123456789101112131415161718192021222324s = pd.Series([1, 2, 3], index= [i for i in range(1,4)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.mean(1))&#x27;&#x27;&#x27; A B C D0 0.128729 -0.642457 -1.474499 NaN1 0.021186 -0.041340 -2.857500 1.02 0.400155 2.757253 -1.097531 2.03 -0.753501 1.087295 -0.069450 3.04 0.159137 0.214257 0.319562 NaN5 1.489170 -0.616156 1.099160 NaN==============================0 -0.6627431 -0.4694132 1.0149693 0.8160864 0.2309855 0.657392dtype: float64&#x27;&#x27;&#x27; 不同维度对象运算时，要先对齐。 此外，Pandas 自动沿指定维度偏移（空填充 NaN）。 123456789101112131415161718192021222324s1 = pd.Series([1, 3, 5, np.nan, 6, 8], index=[i for i in range(6)])s2 = pd.Series([1, 3, 5, np.nan, 6, 8], index=[i for i in range(6)]).shift(2)print(s1)print(&quot;=&quot;*30)print(s2)&#x27;&#x27;&#x27;0 1.01 3.02 5.03 NaN4 6.05 8.0dtype: float64==============================0 NaN1 NaN2 1.03 3.04 5.05 NaNdtype: float64&#x27;&#x27;&#x27; 对不同维度的 pandas 对象按 index 进行减法操作 1234567891011121314151617181920212223s = pd.Series([1, 3, 5, np.nan, 6, 8], index=[i for i in range(6)]).shift(2)print(df)print(&quot;=&quot;*30)print(df.sub(s, axis=&#x27;index&#x27;)) # 对不同维度的 pandas 对象进行减法操作&#x27;&#x27;&#x27; A B C0 -0.584577 1.600920 0.0862181 0.618951 1.851896 -0.4247032 -1.275505 0.841881 0.9229403 -0.190054 -0.358825 -0.5404334 -1.572596 -0.472747 2.3427295 0.328756 -0.890938 -0.099436============================== A B C0 NaN NaN NaN1 NaN NaN NaN2 -2.275505 -0.158119 -0.0770603 -3.190054 -3.358825 -3.5404334 -6.572596 -5.472747 -2.6572715 NaN NaN NaN&#x27;&#x27;&#x27; Apply 函数np.cumsum() 计算轴向元素累加和 123456789101112131415161718192021222324s = pd.Series([1, 3, 5, 7, np.nan, 9], index=[i for i in range(6)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.apply(np.cumsum))&#x27;&#x27;&#x27; A B C D0 -2.061076 0.933043 0.593438 1.01 0.521699 0.100992 0.803118 3.02 -0.648522 1.948277 0.424076 5.03 0.353591 0.956902 0.725868 7.04 0.015446 2.114823 -0.113994 NaN5 0.187891 -0.402199 -0.408387 9.0============================== A B C D0 -2.061076 0.933043 0.593438 1.01 -1.539376 1.034036 1.396556 4.02 -2.187898 2.982312 1.820633 9.03 -1.834308 3.939215 2.546501 16.04 -1.818861 6.054038 2.432507 NaN5 -1.630970 5.651839 2.024119 25.0&#x27;&#x27;&#x27; lambda 计算列最大值与最小值差 12345678910111213141516171819202122s = pd.Series([1, 3, 5, 7, np.nan, 9], index=[i for i in range(6)])df[&quot;D&quot;] = sprint(df)print(&quot;=&quot;*30)print(df.apply(lambda x: x.max() - x.min()))&#x27;&#x27;&#x27; A B C D0 -0.458813 0.887916 -1.148145 1.01 -0.641170 -0.508265 1.569428 3.02 2.144850 -0.914715 1.502805 5.03 -2.162331 0.916027 -0.552572 7.04 -0.715221 0.741209 1.283300 NaN5 -0.952700 0.759135 0.839457 9.0==============================A 4.307181B 1.830742C 2.717572D 8.000000dtype: float64&#x27;&#x27;&#x27; 字符串方法Series 的 str 属性包含一组字符串处理功能 12345678910111213141516s = pd.Series([&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;Aaba&#x27;, &#x27;Baca&#x27;, np.nan, &#x27;CABA&#x27;, &#x27;dog&#x27;, &#x27;cat&#x27;])# print(s.str.upper())print(s.str.lower()) # 字符串转小写&#x27;&#x27;&#x27;0 a1 b2 c3 aaba4 baca5 NaN6 caba7 dog8 catdtype: object&#x27;&#x27;&#x27; 合并（Merge）结合（Concat）Pandas 提供了多种将 Series、 DataFrame 对象组合在一起的功能，用索引与关联代数功能的多种设置逻辑可执行连接 join 与合并 merge 操作。 1234567891011121314151617181920212223242526272829303132333435363738# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npdf = pd.DataFrame(np.random.randn(10,3), index = [i for i in range(10)], columns = [&quot;A&quot;, &quot;B&quot;, &quot;C&quot;])# 分割为多组pie = [df[:3],df[7:]]print(df)print(&quot;=&quot;*30)print(pd.concat(pie))&#x27;&#x27;&#x27; A B C0 1.165033 -0.384343 2.1950761 1.103231 0.897121 -1.5396382 -0.740862 -1.330342 0.7582743 -0.989859 -0.129917 -1.8216864 0.248147 -0.009504 -0.2409905 0.465128 0.874807 0.3978166 2.649065 2.967698 2.9027267 0.902977 2.218083 -0.2318968 -1.029878 0.252509 -0.4992499 0.299016 0.748987 -2.134939============================== A B C0 1.165033 -0.384343 2.1950761 1.103231 0.897121 -1.5396382 -0.740862 -1.330342 0.7582747 0.902977 2.218083 -0.2318968 -1.029878 0.252509 -0.4992499 0.299016 0.748987 -2.134939&#x27;&#x27;&#x27; 连接（join）123456789101112131415161718192021222324252627282930313233343536373839# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as np# left = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;leftVal&#x27;: [1, 2]&#125;)# right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;], &#x27;rightVal&#x27;: [4, 5]&#125;)## df = pd.merge(left, right, on=&#x27;key&#x27;) # key 相同 计算方式：叉积## print(left)# print(right)# print(&quot;=&quot;*30)# print(df)left = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;lval&#x27;: [1, 2]&#125;)right = pd.DataFrame(&#123;&#x27;key&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;], &#x27;rval&#x27;: [4, 5]&#125;)df = pd.merge(left, right, on=&#x27;key&#x27;) # key 不相同 计算方式：交集print(left)print(right)print(&quot;=&quot;*30)print(df)&#x27;&#x27;&#x27; key lval0 foo 11 bar 2 key rval0 foo 41 bar 5============================== key lval rval0 foo 1 41 bar 2 5&#x27;&#x27;&#x27; 追加（Append）123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npdf = pd.DataFrame(np.random.randn(3, 4), columns=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;])s = df.iloc[-1]print(df)print(&quot;=&quot;*30)print(df.append(s, ignore_index=True))&#x27;&#x27;&#x27; A B C D0 0.611300 -0.800572 -0.353525 -1.2367681 1.525472 0.664762 -0.801413 -0.0479372 -1.012871 1.016602 -1.807150 -0.570177============================== A B C D0 0.611300 -0.800572 -0.353525 -1.2367681 1.525472 0.664762 -0.801413 -0.0479372 -1.012871 1.016602 -1.807150 -0.5701773 -1.012871 1.016602 -1.807150 -0.570177&#x27;&#x27;&#x27; 分组（Grouping）groupby 指的是涵盖下列一项或多项步骤的处理流程： 分割：按条件把数据分割成多组； 应用：为每组单独应用函数； 组合：将处理结果组合成一个数据结构。 先分组，再用 sum() 函数计算每组的汇总数据 1234567891011121314151617181920212223242526272829303132# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npdf = pd.DataFrame(&#123; &#x27;A&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;], &#x27;B&#x27;: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;two&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], &#x27;C&#x27;: np.random.randn(7), &#x27;D&#x27;: np.random.randn(7) &#125;)print(df)print(&quot;=&quot;*30)print(df.groupby(&#x27;A&#x27;).sum())&#x27;&#x27;&#x27; A B C D0 foo one 1.308640 -0.0238311 bar one -1.076809 -0.4895032 foo two -0.905921 1.3849163 bar three -1.241199 -0.0066804 foo two 1.874379 -1.5493965 bar two -0.277820 -0.6366386 foo three 1.214788 0.946836============================== C DAbar -2.595828 -1.132822foo 3.491886 0.758525&#x27;&#x27;&#x27; 多列分组后，生成多层索引，也可以应用 sum() 函数 1234567891011121314151617181920212223242526272829df = pd.DataFrame(&#123; &#x27;A&#x27;: [&#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;foo&#x27;], &#x27;B&#x27;: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;, &#x27;two&#x27;, &#x27;two&#x27;, &#x27;three&#x27;], &#x27;C&#x27;: np.random.randn(7), &#x27;D&#x27;: np.random.randn(7) &#125;)print(df)print(&quot;=&quot;*30)print(df.groupby([&#x27;A&#x27;, &#x27;B&#x27;]).sum())&#x27;&#x27;&#x27; A B C D0 foo one -0.042610 0.4228041 bar one -0.784786 2.4760762 foo two 0.131051 0.1371283 bar three -0.859655 -0.8546774 foo two 0.032752 -0.4371605 bar two 0.150680 0.6071426 foo three 1.276175 1.193811============================== C DA Bbar one -0.784786 2.476076 three -0.859655 -0.854677 two 0.150680 0.607142foo one -0.042610 0.422804 three 1.276175 1.193811 two 0.163803 -0.300032&#x27;&#x27;&#x27; 重塑（Reshaping）堆叠（Stack）1234567891011121314151617181920212223242526272829# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as nptuples = list(zip(*[ [&#x27;bar&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;baz&#x27;,&#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;qux&#x27;, &#x27;qux&#x27;], [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;,&#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;] ]))# 设置堆叠index = pd.MultiIndex.from_tuples(tuples, names=[&#x27;first&#x27;, &#x27;second&#x27;])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[&#x27;A&#x27;, &#x27;B&#x27;])print(df)&#x27;&#x27;&#x27; A Bfirst secondbar one -1.336275 -0.030989 two 0.368196 0.130646baz one -0.812696 -0.482284 two 0.964527 -0.868157foo one 0.515658 -0.894977 two -0.576530 -0.778433qux one -1.153507 1.761371 two -0.954842 -0.315546&#x27;&#x27;&#x27; 压缩后的 DataFrame 或 Series 具有多层索引， stack() 的逆操作是 **unstack()**，默认为拆叠最后一层 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566tuples = list(zip(*[ [&#x27;bar&#x27;, &#x27;bar&#x27;, &#x27;baz&#x27;, &#x27;baz&#x27;,&#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;qux&#x27;, &#x27;qux&#x27;], [&#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;,&#x27;one&#x27;, &#x27;two&#x27;, &#x27;one&#x27;, &#x27;two&#x27;] ]))# 设置堆叠index = pd.MultiIndex.from_tuples(tuples, names=[&#x27;first&#x27;, &#x27;second&#x27;])df = pd.DataFrame(np.random.randn(8, 2), index=index, columns=[&#x27;A&#x27;, &#x27;B&#x27;])stacked = df.stack()print(stacked)print(&quot;=&quot;*30)print(stacked.unstack())print(&quot;=&quot;*30)print(stacked.unstack(1))print(&quot;=&quot;*30)print(stacked.unstack(0))&#x27;&#x27;&#x27;first secondbar one A 1.045996 B 0.605382 two A -1.885341 B 0.515791baz one A 0.282474 B 0.063214 two A -2.581561 B -0.479922foo one A -0.343941 B 0.450805 two A -1.067748 B 1.004922qux one A -1.413637 B 2.494043 two A -0.305369 B -0.317468dtype: float64============================== A Bfirst secondbar one 1.045996 0.605382 two -1.885341 0.515791baz one 0.282474 0.063214 two -2.581561 -0.479922foo one -0.343941 0.450805 two -1.067748 1.004922qux one -1.413637 2.494043 two -0.305369 -0.317468==============================second one twofirstbar A 1.045996 -1.885341 B 0.605382 0.515791baz A 0.282474 -2.581561 B 0.063214 -0.479922foo A -0.343941 -1.067748 B 0.450805 1.004922qux A -1.413637 -0.305369 B 2.494043 -0.317468==============================first bar baz foo quxsecondone A 1.045996 0.282474 -0.343941 -1.413637 B 0.605382 0.063214 0.450805 2.494043two A -1.885341 -2.581561 -1.067748 -0.305369 B 0.515791 -0.479922 1.004922 -0.317468&#x27;&#x27;&#x27; 数据透视表（Pivot Tables）123456789101112131415161718# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npdf = pd.DataFrame(&#123; &#x27;A&#x27;: [&#x27;one&#x27;, &#x27;one&#x27;, &#x27;two&#x27;, &#x27;three&#x27;] * 3, &#x27;B&#x27;: [&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;] * 4, &#x27;C&#x27;: [&#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;foo&#x27;, &#x27;bar&#x27;, &#x27;bar&#x27;, &#x27;bar&#x27;] * 2, &#x27;D&#x27;: np.random.randn(12) &#125;)print(df)print(&quot;=&quot;*30)pt = pd.pivot_table(df, values=&#x27;D&#x27;, index=[&#x27;A&#x27;, &#x27;B&#x27;], columns=[&#x27;C&#x27;])print(pt) 类别型（Categoricals）Pandas 的 DataFrame 里可以包含类别数据。 将 grade 的原生数据转换为类别型数据 12345678910111213141516171819202122232425df = pd.DataFrame(&#123;&quot;id&quot;: [1, 2, 3, 4, 5, 6], &quot;raw_grade&quot;: [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;b&#x27;, &#x27;a&#x27;, &#x27;a&#x27;, &#x27;e&#x27;]&#125;)print(df)print(&quot;=&quot;*30)df[&quot;grade&quot;] = df[&quot;raw_grade&quot;].astype(&quot;category&quot;)print(df[&quot;grade&quot;])&#x27;&#x27;&#x27; id raw_grade0 1 a1 2 b2 3 b3 4 a4 5 a5 6 e==============================0 a1 b2 b3 a4 a5 eName: grade, dtype: categoryCategories (3, object): [&#x27;a&#x27;, &#x27;b&#x27;, &#x27;e&#x27;]&#x27;&#x27;&#x27; 可视化1234567891011121314# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltts = pd.Series(np.random.randn(1000), index=pd.date_range(&#x27;1/1/2020&#x27;, periods=1000))ts = ts.cumsum()ts.plot()plt.show() DataFrame 的 plot() 方法可以快速绘制所有带标签的列 123456789101112131415161718# -*- coding:utf-8 -*-# @Time : 2020-10-05# @Author : xmlimport pandas as pdimport numpy as npimport matplotlib.pyplot as pltts = pd.Series(np.random.randn(1000), index=pd.date_range(&#x27;1/1/2020&#x27;, periods=1000))df = pd.DataFrame(np.random.randn(1000, 4), index=ts.index, columns=[&#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;])df = df.cumsum()plt.figure()df.plot()plt.legend(loc=&#x27;best&#x27;)plt.show() 数据输入 / 输出CSV写入 CSV 文件 1df.to_csv(&#x27;output.csv&#x27;) 读取 CSV 文件 1pd.read_csv(&#x27;input.csv&#x27;) Excel写入 Excel 文件 1df.to_excel(&#x27;output.xlsx&#x27;, sheet_name=&#x27;Sheet1&#x27;) 读取 Excel 文件 1pd.read_excel(&#x27;input.xlsx&#x27;, &#x27;Sheet1&#x27;, index_col=None, na_values=[&#x27;NA&#x27;])","categories":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://zedmoster.github.io/tags/pandas/"}]},{"title":"ffmpeg 操作手册","slug":"0.learn_FFmpeg/ffmpeg 使用手册","date":"2021-02-23T12:00:01.000Z","updated":"2021-02-24T11:16:50.280Z","comments":true,"path":"2021/02/23/0.learn_FFmpeg/ffmpeg 使用手册/","link":"","permalink":"https://zedmoster.github.io/2021/02/23/0.learn_FFmpeg/ffmpeg%20%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/","excerpt":"下载 ffmpeg百度网盘：点击下载 提取码：8cjl ffmpeg 简单用法","text":"下载 ffmpeg百度网盘：点击下载 提取码：8cjl ffmpeg 简单用法 12345ffmpeg -i out.ogv -vcodec h264 out.mp4ffmpeg -i out.ogv -vcodec mpeg4 out.mp4ffmpeg -i out.ogv -vcodec libxvid out.mp4ffmpeg -i out.mp4 -vcodec wmv1 out.wmvffmpeg -i out.mp4 -vcodec wmv2 out.wmv -i 后面是输入文件名。 -vcodec 后面是编码格式，h264 最佳，但 Windows 系统默认不安装。 如果是要插入 ppt 的视频，选择 wmv1 或 wmv2 基本上万无一失。 附加选项：-r 指定帧率，-s 指定分辨率，-b 指定比特率；于此同时可以对声道进行转码，-acodec 指定音频编码，-ab 指定音频比特率，-ac 指定声道数，例如 1ffmpeg -i out.ogv -s 640x480 -b 500k -vcodec h264 -r 29.97 -acodec libfaac -ab 48k -ac 2 out.mp4 批量转换12345678for %i in (*.flv) do ffmpeg -i %i -c copy &quot;newfiles\\%~nv.mp4&quot;for %i in (*.mov) do ffmpeg -i %i -c copy &quot;newfiles\\%~nv.mp4&quot;//批量转换视频格式ffmpeg -i xxx.avi -vcodec copy -f mp4 xxx.mp4//批量转换视频格式 --设定分辨率 --设置新文件位置for /R %v IN (*.mp4) do ( ffmpeg -i %v -vcodec h264 -vf scale=720:-2 -threads 4 &quot;newfiles\\%~nv.mp4&quot;) 剪切用 -ss 和 -t 选项， 从第 30 秒开始，向后截取 10 秒的视频，并保存： 12ffmpeg -i input.wmv -ss 00:00:30.0 -c copy -t 00:00:10.0 output.wmvffmpeg -i input.wmv -ss 30 -c copy -t 10 output.wmv 达成相同效果，也可以用 -ss 和 -to 选项， 从第 30 秒截取到第 40 秒： 1ffmpeg -i input.wmv -ss 30 -c copy -to 40 output.wmv 值得注意的是，ffmpeg 为了加速，会使用关键帧技术， 所以有时剪切出来的结果在起止时间上未必准确。 通常来说，把 -ss 选项放在 -i 之前，会使用关键帧技术； 把 -ss 选项放在 -i 之后，则不使用关键帧技术。 如果要使用关键帧技术又要保留时间戳，可以加上 -copyts 选项： 1ffmpeg -ss 00:01:00 -i video.mp4 -to 00:02:00 -c copy -copyts cut.mp4 截取视频段：输入”input.mp4”从 3 分钟开始截取视频段 60s 并保存输出为”output.mp4” 1ffmpeg -ss 00:03:00 -i input.mp4 -t 60 -c:v copy -c:a copy output.mp4 合并把两个视频文件合并成一个。简单地使用 concat demuxer，示例： 123456$ cat mylist.txtfile &#x27;/path/to/file1&#x27;file &#x27;/path/to/file2&#x27;file &#x27;/path/to/file3&#x27;$ ffmpeg -f concat -i mylist.txt -c copy output 更多时候，由于输入文件的多样性，需要转成中间格式再合成： 1234ffmpeg -i input1.avi -qscale:v 1 intermediate1.mpgffmpeg -i input2.avi -qscale:v 1 intermediate2.mpgcat intermediate1.mpg intermediate2.mpg &gt; intermediate_all.mpgffmpeg -i intermediate_all.mpg -qscale:v 2 output.avi 合并视频及音频文件 1ffmpeg -i 0.mp4 -i 1.mp3 -c:v copy -c:a aac -strict experimental -map 0:v:0 -map 1:a:0 output.mp4 帧率设置使用-r 选项语法是： 1ffmpeg -i input -r fps output 例如： 1ffmpeg -i input.avi -r 30 output.mp4 比特率设置比特率也是一个决定音视频总体质量的参数。他决定每个时间单位处理的 bit 数。 设置比特率：比特率决定处理 1s 的编码流需要多少 bits，设置用-b 选项。区分音视频用-b:a 和-b:v 例如：设置整体 1.5Mbit 每秒 123ffmpeg -i file.avi -b 8M file.mp4ffmpeg -i input.avi -b:v 1500K output.mp4 去除水印设置: delogo= 水印位置：x=1000:y=15 水印大小：:w=250:h=160 显示绿框：:show=1（成品去除参数） 12345测试：ffmpeg -i logo.mp4 -filter_complex &quot;delogo=x=1000:y=15:w=250:h=160:show=1&quot; delogo.mp4水印：ffmpeg -i logo.mp4 -filter_complex &quot;delogo=x=1000:y=15:w=250:h=160&quot; delogo.mp4","categories":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zedmoster.github.io/categories/ffmpeg/"}],"tags":[{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zedmoster.github.io/tags/ffmpeg/"}]},{"title":"年薪50W+的Python程序员如何写代码","slug":"1.python/年薪50W+的Python程序员如何写代码","date":"2021-02-23T12:00:00.000Z","updated":"2021-02-24T11:20:09.644Z","comments":true,"path":"2021/02/23/1.python/年薪50W+的Python程序员如何写代码/","link":"","permalink":"https://zedmoster.github.io/2021/02/23/1.python/%E5%B9%B4%E8%96%AA50W+%E7%9A%84Python%E7%A8%8B%E5%BA%8F%E5%91%98%E5%A6%82%E4%BD%95%E5%86%99%E4%BB%A3%E7%A0%81/","excerpt":"年薪 50W+的 Python 程序员如何写代码为什么要用 Python 写代码没有对比就没有伤害 很多互联网和移动互联网企业对开发效率的要求高于对执行效率的要求。","text":"年薪 50W+的 Python 程序员如何写代码为什么要用 Python 写代码没有对比就没有伤害 很多互联网和移动互联网企业对开发效率的要求高于对执行效率的要求。 例子 1：hello, worldC 的版本： 123456#include &lt;stdio.h&gt;int main() &#123; printf(&quot;hello, world\\n&quot;); return 0;&#125; Java 的版本： 123456class Example01 &#123; public static void main(String[] args) &#123; System.out.println(&quot;hello, world&quot;); &#125;&#125; Python 的版本： 1print(&#x27;hello, world&#x27;) 例子 2：1-100 求和C 的版本： 12345678910#include &lt;stdio.h&gt;int main() &#123; int total = 0; for (int i = 1; i &lt;= 100; ++i) &#123; total += i; &#125; printf(&quot;%d\\n&quot;, total);return 0;&#125; Python 的版本： 1print(sum(range(1, 101))) 例子 3：创建和初始化数组（列表）Java 的版本： 12345678910111213141516import java.util.Arrays;public class Example03 &#123; public static void main(String[] args) &#123; boolean[] values = new boolean[10]; Arrays.fill(values, true); System.out.println(Arrays.toString(values)); int[] numbers = new int[10]; for (int i = 0; i &lt; numbers.length; ++i) &#123; numbers[i] = i + 1; &#125; System.out.println(Arrays.toString(numbers)); &#125;&#125; Python 的版本： 1234values = [True] * 10print(values)numbers = [x for x in range(1, 11)]print(numbers) 例子 4：双色球随机选号Java 的版本： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import java.util.List;import java.util.ArrayList;import java.util.Collections;import java.util.Scanner;class Example03 &#123; /** * 产生[min, max)范围的随机整数 */ public static int randomInt(int min, int max) &#123; return (int) (Math.random() * (max - min) + min); &#125; /** * 输出一组双色球号码 */ public static void display(List&lt;Integer&gt; balls) &#123; for (int i = 0; i &lt; balls.size(); ++i) &#123; System.out.printf(&quot;%02d &quot;, balls.get(i)); if (i == balls.size() - 2) &#123; System.out.print(&quot;| &quot;); &#125; &#125; System.out.println(); &#125; /** * 生成一组随机号码 */ public static List&lt;Integer&gt; generate() &#123; List&lt;Integer&gt; redBalls = new ArrayList&lt;&gt;(); for (int i = 1; i &lt;= 33; ++i) &#123; redBalls.add(i); &#125; List&lt;Integer&gt; selectedBalls = new ArrayList&lt;&gt;(); for (int i = 0; i &lt; 6; ++i) &#123; selectedBalls.add(redBalls.remove(randomInt(0, redBalls.size()))); &#125; Collections.sort(selectedBalls); selectedBalls.add(randomInt(1, 17)); return selectedBalls; &#125; public static void main(String[] args) &#123; try (Scanner sc = new Scanner(System.in)) &#123; System.out.print(&quot;机选几注: &quot;); int num = sc.nextInt(); for (int i = 0; i &lt; num; ++i) &#123; display(generate()); &#125; &#125; &#125;&#125; Python 的版本： 123456789101112131415161718192021222324from random import randint, sampledef generate(): &quot;&quot;&quot;生成一组随机号码&quot;&quot;&quot; red_balls = [x for x in range(1, 34)] selected_balls = sample(red_balls, 6) selected_balls.sort() selected_balls.append(randint(1, 16)) return selected_ballsdef display(balls): &quot;&quot;&quot;输出一组双色球号码&quot;&quot;&quot; for index, ball in enumerate(balls): print(f&#x27;&#123;ball:0&gt;2d&#125;&#x27;, end=&#x27; &#x27;) if index == len(balls) - 2: print(&#x27;|&#x27;, end=&#x27; &#x27;) print()num = int(input(&#x27;机选几注: &#x27;))for _ in range(num): display(generate()) 温馨提示：珍爱生命，远离任何形式的赌博。 例子 5：实现一个简单的 HTTP 服务器Java 的版本： 说明：JDK 1.6 以前，需要通过套接字编程来实现，具体又可以分为多线程和 NIO 两种做法。JDK 1.6 以后，可以使用com.sun.net.httpserver包提供的HttpServer类来实现。 12345678910111213141516171819202122232425262728import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.net.httpserver.HttpServer;import java.io.IOException;import java.io.OutputStream;import java.net.InetSocketAddress;class Example05 &#123; public static void main(String[] arg) throws Exception &#123; HttpServer server = HttpServer.create(new InetSocketAddress(8000), 0); server.createContext(&quot;/&quot;, new RequestHandler()); server.start(); &#125; static class RequestHandler implements HttpHandler &#123; @Override public void handle(HttpExchange exchange) throws IOException &#123; String response = &quot;&lt;h1&gt;hello, world&lt;/h1&gt;&quot;; exchange.sendResponseHeaders(200, 0); try (OutputStream os = exchange.getResponseBody()) &#123; os.write(response.getBytes()); &#125; &#125; &#125;&#125; Python 的版本： 12345678910111213from http.server import HTTPServer, SimpleHTTPRequestHandlerclass RequestHandler(SimpleHTTPRequestHandler): def do_GET(self): self.send_response(200) self.end_headers() self.wfile.write(&#x27;&lt;h1&gt;hello, world&lt;/h1&gt;&#x27;.encode())server = HTTPServer((&#x27;&#x27;, 8000), RequestHandler)server.serve_forever() 或 1python3 -m http.server 8000 一行 Python 代码可以做什么 很多时候，你的问题只需一行 Python 代码就能解决。 1234567891011121314# 一行代码实现求阶乘函数fac = lambda x: __import__(&#x27;functools&#x27;).reduce(int.__mul__, range(1, x + 1), 1)# 一行代码实现求最大公约数函数gcd = lambda x, y: y % x and gcd(y % x, x) or x# 一行代码实现判断素数的函数is_prime = lambda x: x &gt; 1 and not [f for f in range(2, int(x ** 0.5) + 1) if x % f == 0]# 一行代码实现快速排序quick_sort = lambda items: len(items) and quick_sort([x for x in items[1:] if x &lt; items[0]]) + [items[0]] + quick_sort([x for x in items[1:] if x &gt; items[0]]) or items# 生成FizzBuzz列表[&#x27;Fizz&#x27;[x % 3 * 4:] + &#x27;Buzz&#x27;[x % 5 * 4:] or x for x in range(1, 101)] 设计模式从未如此简单 Python 是动态类型语言，大量的设计模式在 Python 中被简化或弱化。 思考：如何优化下面的代码。 1234def fib(num): if num in (1, 2): return 1 return fib(num - 1) + fib(num - 2) 代理模式在 Python 中可以通过内置的或自定义的装饰器来实现。 123456789101112from functools import lru_cache@lru_cache()def fib(num): if num in (1, 2): return 1 return fib(num - 1) + fib(num - 2)for n in range(1, 121): print(f&#x27;&#123;n&#125;: &#123;fib(n)&#125;&#x27;) 说明：通过 Python 标准库functools模块的lru_cache装饰器为fib函数加上缓存代理，缓存函数执行的中间结果，优化代码的性能。 单例模式在 Python 中可以通过自定义的装饰器或元类来实现。 123456789101112131415from functools import wrapsfrom threading import RLockdef singleton(cls): instances = &#123;&#125; lock = RLock() @wraps(cls) def wrapper(*args, **kwargs): if cls not in instances: with lock: if cls not in instances: instances[cls] = cls(*args, **kwargs) return instances[cls] 说明：需要实现单例模式的类只需要添加上面的装饰器即可。 原型模式在 Python 中可以通过元类来实现。 123456789import copyclass PrototypeMeta(type): def __init__(cls, *args, **kwargs): super().__init__(*args, **kwargs) cls.clone = lambda self, is_deep=True: \\ copy.deepcopy(self) if is_deep else copy.copy(self) 说明：通过元类给指定了metaclass=PrototypeMeta的类添加一个clone方法实现对象克隆，利用 Python 标准库copy模块的copy和deepcopy分别实现浅拷贝和深拷贝。 数据采集和数据分析从未如此简单 网络数据采集是 Python 最擅长的领域之一。 例子：获取豆瓣电影“Top250”。 123456789101112131415import randomimport timeimport requestsfrom bs4 import BeautifulSoupfor page in range(10): resp = requests.get( url=f&#x27;https://movie.douban.com/top250?start=&#123;25 * page&#125;&#x27;, headers=&#123;&#x27;User-Agent&#x27;: &#x27;BaiduSpider&#x27;&#125; ) soup = BeautifulSoup(resp.text, &quot;lxml&quot;) for elem in soup.select(&#x27;a &gt; span.title:nth-child(1)&#x27;): print(elem.text) time.sleep(random.random() * 5) 利用 NumPy、Pandas、Matplotlib 可以轻松实现数据分析和可视化。 写出 Python 代码的正确姿势 用 Python 写代码就要写出 Pythonic 的代码。 姿势 1：选择结构的正确姿势跨界开发者的代码： 12345name = &#x27;jackfrued&#x27;fruits = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;grape&#x27;]owners = &#123;&#x27;name&#x27;: &#x27;骆昊&#x27;, &#x27;age&#x27;: 40, &#x27;gender&#x27;: True&#125;if name != &#x27;&#x27; and len(fruits) &gt; 0 and len(owners.keys()) &gt; 0: print(&#x27;Jackfrued love fruits.&#x27;) Pythonic 的代码： 12345name = &#x27;jackfrued&#x27;fruits = [&#x27;apple&#x27;, &#x27;orange&#x27;, &#x27;grape&#x27;]owners = &#123;&#x27;name&#x27;: &#x27;骆昊&#x27;, &#x27;age&#x27;: 40, &#x27;gender&#x27;: True&#125;if name and fruits and owners: print(&#x27;Jackfrued love fruits.&#x27;) 姿势 2：交换两个变量的正确姿势跨界开发者的代码： 123temp = aa = bb = temp 或 123a = a ^ bb = a ^ ba = a ^ b Pythonic 的代码： 1a, b = b, a 姿势 3：用序列组装字符串的正确姿势跨界开发者的代码： 1234chars = [&#x27;j&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;k&#x27;, &#x27;f&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;e&#x27;, &#x27;d&#x27;]name = &#x27;&#x27;for char in chars: name += char Pythonic 的代码： 12chars = [&#x27;j&#x27;, &#x27;a&#x27;, &#x27;c&#x27;, &#x27;k&#x27;, &#x27;f&#x27;, &#x27;r&#x27;, &#x27;u&#x27;, &#x27;e&#x27;, &#x27;d&#x27;]name = &#x27;&#x27;.join(chars) 姿势 4：遍历列表的正确姿势跨界开发者的代码： 12345fruits = [&#x27;orange&#x27;, &#x27;grape&#x27;, &#x27;pitaya&#x27;, &#x27;blueberry&#x27;]index = 0for fruit in fruits: print(index, &#x27;:&#x27;, fruit) index += 1 Pythonic 的代码： 123fruits = [&#x27;orange&#x27;, &#x27;grape&#x27;, &#x27;pitaya&#x27;, &#x27;blueberry&#x27;]for index, fruit in enumerate(fruits): print(index, &#x27;:&#x27;, fruit) 姿势 5：创建列表的正确姿势跨界开发者的代码： 12345data = [7, 20, 3, 15, 11]result = []for i in data: if i &gt; 10: result.append(i * 3) Pythonic 的代码： 12data = [7, 20, 3, 15, 11]result = [num * 3 for num in data if num &gt; 10] 姿势 6：确保代码健壮性的正确姿势跨界开发者的代码： 1234567data = &#123;&#x27;x&#x27;: &#x27;5&#x27;&#125;if &#x27;x&#x27; in data and isinstance(data[&#x27;x&#x27;], (str, int, float)) \\ and data[&#x27;x&#x27;].isdigit(): value = int(data[&#x27;x&#x27;]) print(value)else: value = None Pythonic 的代码： 123456data = &#123;&#x27;x&#x27;: &#x27;5&#x27;&#125;try: value = int(data[&#x27;x&#x27;]) print(value)except (KeyError, TypeError, ValueError): value = None 使用 Lint 工具检查你的代码规范阅读下面的代码，看看你能看出哪些地方是有毛病的或者说不符合 Python 的编程规范的。 1234567891011121314151617181920212223242526272829303132333435363738from enum import *@uniqueclass Suite (Enum): SPADE, HEART, CLUB, DIAMOND = range(4)class Card(object): def __init__(self,suite,face ): self.suite = suite self.face = face def __repr__(self): suites=&#x27;♠♥♣♦&#x27; faces=[&#x27;&#x27;,&#x27;A&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;10&#x27;,&#x27;J&#x27;,&#x27;Q&#x27;,&#x27;K&#x27;] return f&#x27;&#123;suites[self.suite.value]&#125;&#123;faces[self.face]&#125;&#x27;import randomclass Poker(object): def __init__(self): self.cards =[Card(suite, face) for suite in Suite for face in range(1, 14)] self.current=0 def shuffle (self): self.current=0 random.shuffle(self.cards) def deal (self): card = self.cards[self.current] self.current+=1 return card def has_next (self): if self.current&lt;len(self.cards): return True return Falsep = Poker()p.shuffle()print(p.cards) PyLint 的安装和使用Pylint 是 Python 代码分析工具，它分析 Python 代码中的错误，查找不符合代码风格标准（默认使用的代码风格是 PEP 8）和有潜在问题的代码。 12pip install pylintpylint [options] module_or_package Pylint 输出格式如下所示。 模块名:行号:列号: 消息类型 消息 消息类型有以下几种： C - 惯例：违反了 Python 编程惯例（PEP 8）的代码。 R - 重构：写得比较糟糕需要重构的代码。 W - 警告：代码中存在的不影响代码运行的问题。 E - 错误：代码中存在的影响代码运行的错误。 F - 致命错误：导致 Pylint 无法继续运行的错误。 Pylint 命令的常用参数： --disable=&lt;msg ids&gt;或-d &lt;msg ids&gt;：禁用指定类型的消息。 --errors-only或-E：只显示错误。 --rcfile=&lt;file&gt;：指定配置文件。 --list-msgs：列出 Pylint 的消息清单。 --generate-rcfile：生成配置文件的样例。 --reports=&lt;y_or_n&gt;或-r &lt;y_or_n&gt;：是否生成检查报告。 使用 Profile 工具剖析你的代码性能cProfile 模块example01.py 12345678910111213141516171819202122232425262728293031import cProfiledef is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return Trueclass PrimeIter: def __init__(self, total): self.counter = 0 self.current = 1 self.total = total def __iter__(self): return self def __next__(self): if self.counter &lt; self.total: self.current += 1 while not is_prime(self.current): self.current += 1 self.counter += 1 return self.current raise StopIteration()cProfile.run(&#x27;list(PrimeIter(10000))&#x27;) 执行结果： 123456789101112114734 function calls in 0.573 secondsOrdered by: standard namencalls tottime percall cumtime percall filename:lineno(function) 1 0.006 0.006 0.573 0.573 &lt;string&gt;:1(&lt;module&gt;) 1 0.000 0.000 0.000 0.000 example.py:14(__init__) 1 0.000 0.000 0.000 0.000 example.py:19(__iter__) 10001 0.086 0.000 0.567 0.000 example.py:22(__next__)104728 0.481 0.000 0.481 0.000 example.py:5(is_prime) 1 0.000 0.000 0.573 0.573 &#123;built-in method builtins.exec&#125; 1 0.000 0.000 0.000 0.000 &#123;method &#39;disable&#39; of &#39;_lsprof.Profiler&#39; objects&#125; line_profiler给需要剖析时间性能的函数加上一个profile装饰器，这个函数每行代码的执行次数和时间都会被剖析。 example02.py 1234567891011121314151617181920212223242526272829@profiledef is_prime(num): for factor in range(2, int(num ** 0.5) + 1): if num % factor == 0: return False return Trueclass PrimeIter: def __init__(self, total): self.counter = 0 self.current = 1 self.total = total def __iter__(self): return self def __next__(self): if self.counter &lt; self.total: self.current += 1 while not is_prime(self.current): self.current += 1 self.counter += 1 return self.current raise StopIteration()list(PrimeIter(1000)) 安装和使用line_profiler三方库。 123456789101112131415161718pip install line_profilerkernprof -lv example.pyWrote profile results to example02.py.lprofTimer unit: 1e-06 sTotal time: 0.089513 sFile: example02.pyFunction: is_prime at line 1 # Hits Time Per Hit % Time Line Contents============================================================== 1 @profile 2 def is_prime(num): 3 86624 43305.0 0.5 48.4 for factor in range(2, int(num ** 0.5) + 1): 4 85624 42814.0 0.5 47.8 if num % factor == 0: 5 6918 3008.0 0.4 3.4 return False 6 1000 386.0 0.4 0.4 return True memory_profiler给需要剖析内存性能的函数加上一个profile装饰器，这个函数每行代码的内存使用情况都会被剖析。 example03.py 123456789@profiledef eat_memory(): items = [] for _ in range(1000000): items.append(object()) return itemseat_memory() 安装和使用memory_profiler三方库。 12345678910111213pip install memory_profilerpython3 -m memory_profiler example.pyFilename: example03.pyLine # Mem usage Increment Line Contents================================================ 1 38.672 MiB 38.672 MiB @profile 2 def eat_memory(): 3 38.672 MiB 0.000 MiB items = [] 4 68.727 MiB 0.000 MiB for _ in range(1000000): 5 68.727 MiB 1.797 MiB items.append(object()) 6 68.727 MiB 0.000 MiB return items 如何构建综合职业素养 学习总结 了解全局 确定范围 定义目标 寻找资源 创建学习计划 筛选资源 开始学习，浅尝辄止（YAGNI） 动手操作，边学边玩 全面掌握，学以致用 乐为人师，融会贯通 时间管理 提升专注力 充分利用碎片时间 使用番茄工作法 时间是怎么浪费掉的 任何行动都比不采取行动好","categories":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/categories/python/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"05.git 使用","slug":"LinuxPrimer/05.git使用","date":"2021-02-09T12:00:05.000Z","updated":"2021-02-08T21:11:34.638Z","comments":true,"path":"2021/02/09/LinuxPrimer/05.git使用/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/LinuxPrimer/05.git%E4%BD%BF%E7%94%A8/","excerpt":"git 基本命令初始化命令、查看状态、管理文件、配置等","text":"git 基本命令初始化命令、查看状态、管理文件、配置等 123456789101112131415161718192021222324# 进入需要管理的文件夹 -- 初始化命令git init# 查看目录下文件的状态git status# 管理指定文件git add 文件名# 管理目录下所有文件及文件夹git add .# 个人信息配置：用户名、邮箱 -- 仅配置一次即可git config --global user.email &quot;UserName@gmail.com&quot;git config --global user.name &quot;UserName&quot;# 设置代理git config --global http.proxy http://127.0.0.1:10809git config --global https.proxy http://127.0.0.1:10809# 生成版本git commit -m &quot;描述版本信息&quot;# 查看版本记录git log 版本控制12345678910# 查看版本git log# 版本回滚到之前的版本git reset --hard 版本号# 回滚到之后的版本git refloggit reset --hard 版本号 自定义一键 add . / commit / push 操作12345678# windows# 打开文件夹 C:\\Program Files\\Git\\etc# 打开文件 .gitconfig# 添加下方内容[alias] ad = &quot;!f() &#123; git add -A &amp;&amp; git commit -m \\&quot;$@\\&quot; &amp;&amp; git push; &#125;; f&quot;# 用法： git ad &quot;commit message&quot;","categories":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"},{"name":"git","slug":"git","permalink":"https://zedmoster.github.io/tags/git/"}]},{"title":"04.vim 自动补齐 python","slug":"LinuxPrimer/04.vim自动补齐python","date":"2021-02-09T12:00:04.000Z","updated":"2021-02-08T21:09:30.958Z","comments":true,"path":"2021/02/09/LinuxPrimer/04.vim自动补齐python/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/LinuxPrimer/04.vim%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90python/","excerpt":"PydictionPydiction 可以使我们使用 Tab 键自动补全 Python 代码在 Vim，是一款非常不错的插件。不需要安装，所有没有任何依赖包问题。","text":"PydictionPydiction 可以使我们使用 Tab 键自动补全 Python 代码在 Vim，是一款非常不错的插件。不需要安装，所有没有任何依赖包问题。 12345678910111213141516171819202122232425262728293031# 创建目录mkdir -p ~/.vim/bundle# 打开目录cd ~/.vim/bundle# 下载 Pydictiongit clone https://github.com/rkulla/pydiction.git# 复制文件到指定位置cp -r ~/.vim/bundle/pydiction/after/ ~/.vim# 新建.vimrc文件vim ~/.vimrc# 在.vimrc文件添加如下配置：filetype plugin onautocmd FileType python set omnifunc=pythoncomplete#Completelet g:pydiction_location=&#x27;~/.vim/bundle/pydiction/complete-dict&#x27;let g:pydiction_menu_height = 4set filetype=pythonau BufNewFile,BufRead *.py,*.pyw setf pythonset autoindentset smartindentset numberset expandtabset tabstop=4set shiftwidth=4set softtabstop=4set textwidth=79set encoding=utf-8set fileformat=unix# 重启后 使用Tab键自动补全python代码了","categories":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"}]},{"title":"03.安装 pip 命令","slug":"LinuxPrimer/03.安装pip命令","date":"2021-02-09T12:00:03.000Z","updated":"2021-02-08T21:09:34.288Z","comments":true,"path":"2021/02/09/LinuxPrimer/03.安装pip命令/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/LinuxPrimer/03.%E5%AE%89%E8%A3%85pip%E5%91%BD%E4%BB%A4/","excerpt":"安装 pip 或 pip3","text":"安装 pip 或 pip3 1234# 安装python2 版本 pipsudo apt install python-pip# 安装python3 版本 pip3sudo apt install python3-pip 仅使用 python3 时使用 pip 代替 pip31234567# 打开配置文件vim ~/.bashrc# 添加替换的内容alias pip=&quot;pip3&quot;alias python=&quot;python3&quot;# 保存后更新配置source ~/.bashrc 更换 pip 源12345678910# 打开创建文件夹mkdir ~/.config/pip/# 打开文件目录cd ~/.config/pip/# 创建并打开文件vim pip.conf# 复制内容并保存[global]index-url = https://pypi.tuna.tsinghua.edu.cn/simple/ 安装卸载软件1234# 安装sudo apt install ipython3# 卸载sudo apt remove ipython3 安装 scrapy 后创建软连接123456# 确定安装位置/usr/local/python3/bin/scrapy# 建立软链接ln -s /usr/local/python3/bin/scrapy /usr/bin/scrapy# 删除软链接rm -rf scrapy","categories":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"}]},{"title":"02.Ubuntu 镜像使用帮助","slug":"LinuxPrimer/02.更换安装源","date":"2021-02-09T12:00:02.000Z","updated":"2021-02-08T21:09:37.106Z","comments":true,"path":"2021/02/09/LinuxPrimer/02.更换安装源/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/LinuxPrimer/02.%E6%9B%B4%E6%8D%A2%E5%AE%89%E8%A3%85%E6%BA%90/","excerpt":"Ubuntu 的软件源配置文件是 /etc/apt/sources.list 设置流 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak cd /etc/apt/ sudo vim sources.list 将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用 TUNA 的软件源镜像。","text":"Ubuntu 的软件源配置文件是 /etc/apt/sources.list 设置流 sudo cp /etc/apt/sources.list /etc/apt/sources.list.bak cd /etc/apt/ sudo vim sources.list 将系统自带的该文件做个备份，将该文件替换为下面内容，即可使用 TUNA 的软件源镜像。 软件源镜像:18.04 LTS123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ bionic-security main restricted universe multiverse 软件源镜像:20.04 LTS123456789# 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiversedeb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse# deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse","categories":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"}]},{"title":"01.Window 安装子系统 Linux","slug":"LinuxPrimer/01.安装子系统","date":"2021-02-09T12:00:01.000Z","updated":"2021-02-08T21:09:39.964Z","comments":true,"path":"2021/02/09/LinuxPrimer/01.安装子系统/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/LinuxPrimer/01.%E5%AE%89%E8%A3%85%E5%AD%90%E7%B3%BB%E7%BB%9F/","excerpt":"设置 -&gt; 应用和功能 -&gt; 启用或关闭 Windows 功能 打开商店，搜素 ubuntu 安装相应版本即可 打开系统，第一次打开等待安装完成后设置用户名及密码","text":"设置 -&gt; 应用和功能 -&gt; 启用或关闭 Windows 功能 打开商店，搜素 ubuntu 安装相应版本即可 打开系统，第一次打开等待安装完成后设置用户名及密码 子系统 ubuntu vim 字体显示12345# 打开注册列表位置# 计算机\\HKEY_CURRENT_USER\\Console\\# 选择 ubuntu 系统目录 右键 添加 &quot;DWORD（32 位）值&quot;# 添加 CodePage# 十进制值 65001 Windows 的 ubuntu 子系统 VsCode 打开 1.Visual Studio Code 安装插件 “Remote - WSL” 2.打开ubuntu子系统,输入 code .","categories":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"}],"tags":[{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"}]},{"title":"2.13 提示 TaskDialog","slug":"PythonScriptPrimer/2.13 提示TaskDialog","date":"2021-02-09T00:08:19.000Z","updated":"2021-02-08T21:06:30.434Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.13 提示TaskDialog/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.13%20%E6%8F%90%E7%A4%BATaskDialog/","excerpt":"创建 TaskDialogTaskDialogs 是 Revit 中的用于提供详细的用户反馈 API 类。它们可以用一行代码执行，如下所示：","text":"创建 TaskDialogTaskDialogs 是 Revit 中的用于提供详细的用户反馈 API 类。它们可以用一行代码执行，如下所示： 1TaskDialog.Show(&quot;Example Title&quot;, &quot;Example Text&quot;) TaskDialogs 可用于向用户提供一定程度的反馈，可能时想报告脚本是成功运行还是遇到什么错误等情况。 自定义 TaskDialogTaskDialog 也可以通过类的属性对其进行编辑，以使内容更加丰富，例如： 1234567task_dialog = TaskDialog(&quot;Example Title&quot;)task_dialog.CommonButtons = TaskDialogCommonButtons.Cancel | TaskDialogCommonButtons.Ok | TaskDialogCommonButtons.Close | TaskDialogCommonButtons.No | TaskDialogCommonButtons.Yes | TaskDialogCommonButtons.Retry | TaskDialogCommonButtons.Nonetask_dialog.FooterText = &quot;Example Footer Text&quot;task_dialog.MainInstruction = &quot;Example Main Instruction&quot;task_dialog.MainContent = &quot;This is the main content for this TaskDialog&quot;task_dialog.Show() 提示窗口样式","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.12 内置类别","slug":"PythonScriptPrimer/2.12 内置类别","date":"2021-02-09T00:08:18.000Z","updated":"2021-02-08T21:06:25.359Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.12 内置类别/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.12%20%E5%86%85%E7%BD%AE%E7%B1%BB%E5%88%AB/","excerpt":"BuiltInCategoryRevit 用户界面向用户显示了许多类别，例如门，楼板和常规模型等。Revit 在内部使用更详细的类别列表，称为内置类别。内置类别的完整列表可以在 BuiltInCategory 枚举中找到-这些是固定编码，不能创建修改。","text":"BuiltInCategoryRevit 用户界面向用户显示了许多类别，例如门，楼板和常规模型等。Revit 在内部使用更详细的类别列表，称为内置类别。内置类别的完整列表可以在 BuiltInCategory 枚举中找到-这些是固定编码，不能创建修改。 检索类别元素由于该列表涵盖了近 1000 个类别，因此可以帮助我门更精确地定位 Revit 元素。内置类别对于 FilteredElementCollectors 尤其有用，它使我们能够准确检索特定的元素。 例如，要收集文档中的所有 面积标签 ： 12area_tags = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_AreaTags).ToElements()OUT = area_tags","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.11 Units 单位处理","slug":"PythonScriptPrimer/2.11 Units单位处理","date":"2021-02-09T00:08:17.000Z","updated":"2021-02-08T21:06:20.431Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.11 Units单位处理/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.11%20Units%E5%8D%95%E4%BD%8D%E5%A4%84%E7%90%86/","excerpt":"Revit 长度Revit 长度内部单位：英尺","text":"Revit 长度Revit 长度内部单位：英尺 123detail_line = UnwrapElement(IN[0])decimal_feet_length = detail_line.GeometryCurve.LengthOUT = decimal_feet_length # 单位：英尺 上面代码返回的数据单位并不是我们常用的毫米单位，所以需要对数据进行单位转换。 单位转换（毫米）使用 Revit 的 UnitUtils 类，且参数只能从 Revit 的 DisplayUnitType 枚举中选择值类型 1234detail_line = UnwrapElement(IN[0])decimal_feet_length = detail_line.GeometryCurve.Lengthmetric_length = UnitUtils.Convert(decimal_feet_length, DisplayUnitType.DUT_DECIMAL_FEET, DisplayUnitType.DUT_MILLIMETERS) # 将英尺转换为毫米OUT = metric_length # 单位：毫米 角度单位转换（弧度）Revit 角度内部单位：弧度 123angle = 90.0 # 角度值radians_equivalent = UnitUtils.Convert(angle, DisplayUnitType.DUT_DECIMAL_DEGREES, DisplayUnitType.DUT_RADIANS) # 将角度转换为弧度OUT = radians_equivalent # 单位：弧度","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.10 提示用户界面选择","slug":"PythonScriptPrimer/2.10 提示用户界面选择","date":"2021-02-09T00:08:16.000Z","updated":"2021-02-08T20:36:20.795Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.10 提示用户界面选择/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.10%20%E6%8F%90%E7%A4%BA%E7%94%A8%E6%88%B7%E7%95%8C%E9%9D%A2%E9%80%89%E6%8B%A9/","excerpt":"","text":"用户选择工作流程有时我们可能会构建一个通用工具，要求用户选择文档中的 Revit 元素（例如，元素重新编号工具）。这将需要无限数量的可自定义过滤器，以使用户能够使用逻辑选择他们选择的元素，但是我们可以通过提示用户选择某些内容来跳过整个问题。 ISelectionFilter 接口ISelectionFilter 可以限制用户可以选择的元素种类。只需要创建一个实现该接口的新类。 然后，将此类的实例作为参数提供给 PickElementsByRectangle() 方法。例如，提示用户选择 Walls 所需的代码为： 123456789101112131415# 加载过滤选择的接口 ISelectionFilterfrom Autodesk.Revit.UI.Selection import ISelectionFilter# 定义选择过滤器class MySelectionFilter(ISelectionFilter): def __init__(self): pass def AllowElement(self, element): return element.Category.Name == &quot;墙&quot; def AllowReference(self, element): return Falseselection_filter = MySelectionFilter() # 仅选择墙walls = uidoc.Selection.PickElementsByRectangle(selection_filter) # 返回框选的墙体OUT = walls","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.9 批处理文档","slug":"PythonScriptPrimer/2.9 批处理文档","date":"2021-02-09T00:08:15.000Z","updated":"2021-02-08T21:06:11.161Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.9 批处理文档/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.9%20%E6%89%B9%E5%A4%84%E7%90%86%E6%96%87%E6%A1%A3/","excerpt":"工作流批处理 Revit 文件 Revit API 的最强大功能之一就是能够以自动方式打开，关闭，编辑和保存文档。最重要的是，我们可以“无头”实现这一目标，这意味着无需任何 GUI 组件即可打开 Revit 文档的数据库。一般而言，以这种方式处理文档可能比用户这样做快 20 到 30 倍-这意味着构建涉及快速批处理许多文件时可以使用这种方式。","text":"工作流批处理 Revit 文件 Revit API 的最强大功能之一就是能够以自动方式打开，关闭，编辑和保存文档。最重要的是，我们可以“无头”实现这一目标，这意味着无需任何 GUI 组件即可打开 Revit 文档的数据库。一般而言，以这种方式处理文档可能比用户这样做快 20 到 30 倍-这意味着构建涉及快速批处理许多文件时可以使用这种方式。 批处理步骤： 根据目标文档的文件路径，创建 Revit FilePath 对象的列表，遍历此文档路径列表 使用 Revit API 的 Open() 方法打开文件并为此打开的文档创建一个句柄 通过其句柄打开针对我们新打开的文档的处理 根据需求进行 API 调用，具体取决于要执行的具体操作 关闭打开文档。如果需要保存更改，可将文档进行另存。 python 节点代码123456789101112131415input_paths = IN[0]# 设置打开方式open_options = OpenOptions()report = []for path in input_paths: filepath = FilePath(path) # 打开文件 family_doc = app.OpenDocumentFile(filepath, open_options) dimensions = FilteredElementCollector(family_doc).OfCategory(BuiltInCategory.OST_Dimensions).WhereElementIsNotElementType().ToElements() number_dimensions = len(dimensions) report.append(&quot;File &#123;&#125; contains &#123;&#125; dimensions&quot;.format(path, number_dimensions)) # 关闭文件 family_doc.Close(False)OUT = report #Outputting the report we generated dynamo 节点","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.8 处理事务 Transactions","slug":"PythonScriptPrimer/2.8 处理事务 Transactions","date":"2021-02-09T00:08:14.000Z","updated":"2021-02-08T21:05:40.782Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.8 处理事务 Transactions/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.8%20%E5%A4%84%E7%90%86%E4%BA%8B%E5%8A%A1%20Transactions/","excerpt":"Revit 是数据库需要对该数据库的更改进行仔细的排序，需要对过程进行管理和检查（针对架构的有效性以及针对 Revit API 设计的合法性）。所有这些都由 Revit 的本机 Transaction API 处理。","text":"Revit 是数据库需要对该数据库的更改进行仔细的排序，需要对过程进行管理和检查（针对架构的有效性以及针对 Revit API 设计的合法性）。所有这些都由 Revit 的本机 Transaction API 处理。 Dynamo’s TransactionManager当直接为 Revit API 编码时，我们可以通过使用代码实例化 Transaction 类的新对象并调用其 Start() 方法来简单地启动新事务。但是，在 Dynamo 中，我们通常使用下面这种方式进行处理。 TransactionManager 是 Dynamo API 的一部分，该 API 处理 Dynamo 应用程序中对 Revit 文档数据库所做的更改： 1234TransactionManager.Instance.EnsureInTransaction(doc) # 为 doc 文档开启事务# 增、删、改操作Revit文档TransactionManager.Instance.TransactionTaskDone() # 提交更新 简而言之，主体代码都写在样板代码的这两行代码之间即可。","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.7 访问图元参数 Parameters","slug":"PythonScriptPrimer/2.7 访问图元参数 Parameters","date":"2021-02-09T00:08:13.000Z","updated":"2021-02-08T21:05:36.341Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.7 访问图元参数 Parameters/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.7%20%E8%AE%BF%E9%97%AE%E5%9B%BE%E5%85%83%E5%8F%82%E6%95%B0%20Parameters/","excerpt":"族、族类型、族实例之间的关系Revit 的族系使用族类型和族实例之间的层次关系。API 中并行存在相同的关系： 族实例 是 Revit 的 FamilyInstance 类的实例。例如：项目中创建的门、窗 族类型 是 Revit 的 FamilyType 类的实例。例如：防火门 FM1822 类型","text":"族、族类型、族实例之间的关系Revit 的族系使用族类型和族实例之间的层次关系。API 中并行存在相同的关系： 族实例 是 Revit 的 FamilyInstance 类的实例。例如：项目中创建的门、窗 族类型 是 Revit 的 FamilyType 类的实例。例如：防火门 FM1822 类型 族实例参数通过 FamilyInstance 对象访问，而族类型的参数通过实例的 FamilyType 类型对象访问。 包含关系：FamilyInstance -&gt; FamilyType -&gt; Family 每个FamilyInstance都是通过FamilyType创建。同样，每个FamilyType将由项目文档中的加载的Family族文件定义。 下面演示如何从FamilyInstance向上找到FamilyType类型，再通过FamilyType找到Family族： 12345family_instance = UnwrapElement(IN[0]) # 展开dynamo图元得到Revit族实例family_type_id = family_instance.GetTypeId() # 获取族实例的类型Idfamily_type = doc.GetElement(family_type_id) # 通过类型Id获取族类型family = family_type.Family # 通过类型获取族FamilyOUT = family_instance, family_type, family # 输出 [族实例, 族类型, 族] 反方向查找：Family对象通常包含多个的FamilyType对象之间存在多对一的关系。同样，有许多放置相同FamilyType的FamilyInstances。要获得一个家庭的所有 family_type，我们可以使用： 1234family = UnwrapElement(IN[0]) # 展开dynamo图元得到Revit族family_type_ids = family.GetFamilySymbolIds() # 获取族包含的所有类型Idfamily_types = [doc.GetElement(id) for id in family_type_ids] # 获取所有的族类型存再列表中OUT = family_types # 输出族类型列表 寻找特定类型的所有FamilyInstance对象是那么简单-我们首先需要创建一个 FamilyInstanceFilter 使用所需FamilyType的 ID。 12345678910111213141516# 展开dynamo图元得到Revit族family = UnwrapElement(IN[0])# 获取族包含的所有类型Idfamily_type_ids = family.GetFamilySymbolIds()# 创建族实例列表family_instances = []# 寻找类型对应的实例for family_type_id in family_type_ids: # 创建指定类型的过滤器 family_instance_filter = FamilyInstanceFilter(doc, family_type_id) # 获取文档中所有类型的实例对象 elements = FilteredElementCollector(doc).WherePasses(family_instance_filter).ToElements() # 将实例对象添加到列表 family_instances.append(elements)# 输出结果OUT = family_instances 族实例和族类型参数获取族实例参数如果要与传递 Dynamo 元素到节点中与 Revit 元素进行交互，则需要将其展开。展开后，可以访问特定参数将所有元素实例参数的列表作为 Parameter 对象返回，可以通过其 Element.Parameters 属性访问，如下所示： 12family_instance = UnwrapElement(IN[0]) # 族实例对象instance_parameters = family_instance.Parameters # 实例包含的所有参数 获取族类型参数类型参数需要通过元素的族类型来访问。如果将FamilyInstance作为输入，则首先需要获取元素的 FamilyType 对象，例如 GetTypeId() 此方法返回元素的族类型的ElementId。然后，我们可以使用 doc.GetElement() 方法返回元素的FamilyType对象。 123family_instance = UnwrapElement(IN[0]) # 族实例对象family_type = doc.GetElement(family_instance.GetTypeId()) # 通过实例获取类型type_parameters = family_type.Parameters # 类型包含的所有参数 访问指定参数对于获取 FamilyInstance 或 FamilyType 的参数，有以下方法来访问特定参数： Element.LookupParameter() Element.get_Parameter() 这两种方法本质上都是相同的。它们返回一个 Parameter 对象。选择 Revit 门实例对象： 获取参数值12input_element = UnwrapElement(IN[0])paratemer = input_element.LookupParameter(&quot;顶高度&quot;) 如果输出原始Parameter对象，它将显示为Autodesk.Revit.DB.Parameter，为了获取参数 Parameter 对象的值，您需要使用 Parameter 类的对其进行转换。 依据判断值的类型进行取值即可： AsDouble() AsElementId() AsInteger() AsString() AsValueString() 使用上面的方法以适当的数据类型返回值。 12input_element = UnwrapElement(IN[0])value = input_element.LookupParameter(&quot;顶高度&quot;).AsValueString() # value = 2400 此工作流程等效于在 Dynamo 中使用 GetParameterValueByName 节点。 设置参数值同样需要获取到Parameter对象，使用 Set() 方法进行赋值即可,当然更改参数的这个操作修改了文件的内容，所以应该开启 Transaction 事务。 。 1234TransactionManager.Instance.EnsureInTransaction(doc) # 事务开始input_element = UnwrapElement(IN[0])input_element.LookupParameter(&quot;顶高度&quot;).Set(2000)TransactionManager.Instance.TransactionTaskDone() # 事务结束 Set 值对象的类型包括： Set(float) Set(int) Set(ElementId) Set(str)","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.6 几何(Geometry)转换","slug":"PythonScriptPrimer/2.6 几何(Geometry)转换","date":"2021-02-09T00:08:12.000Z","updated":"2021-02-08T21:05:27.548Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.6 几何(Geometry)转换/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.6%20%E5%87%A0%E4%BD%95(Geometry)%E8%BD%AC%E6%8D%A2/","excerpt":"Revit 几何图形和 Dynamo 几何图形Dynamo 具有与 Revit 并行的类库。意味着需要使用特殊的转换方法来使两者之间进行转换实现数据交互。前面章节也提到过需要展开对象。","text":"Revit 几何图形和 Dynamo 几何图形Dynamo 具有与 Revit 并行的类库。意味着需要使用特殊的转换方法来使两者之间进行转换实现数据交互。前面章节也提到过需要展开对象。 转换方式您可以使用 Dynamo API 的转换方法轻松地在 Dynamo 和 Revit 几何类型之间进行切换: ToProtoType() ToDSType() ToLine() ToPoint() ToVector() ToXyz() PointsRevit 点在 3D 空间中由其 X，Y 和 Z 坐标定义。创建方法：先创建点的对象 Autodesk.Revit.DB.XYZ，在创建 Revit 点 Autodesk.Revit.DB.Point.Create 方法创建，该方法需要传入点的对象。 12XYZ revit_xyz = new Autodesk.Revit.DB.XYZ(0,0,0) // 创建点对象Point revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz) // 创建点 要创建 Dynamo 点，我们需要使用 Designscript 库，该库是 Dynamo 的一部分。Dynamo 点的类型为 Autodesk.DesignScript.Geometry.Point 如果从 Python 节点输出以下 dynamo_point，它将立即显示在 Dynamo 的 3D 背景预览中。 12dynamo_point = Autodesk.DesignScript.Geometry.Point.ByCoordinates(0,0,0) # 创建点OUT = dynamo_point # 输出点视图将显示 注意：即使我们在这里创建 Revit 对象，在这种情况下，也不需要将它们包装在 Transaction 事务中。 1234revit_xyz = Autodesk.Revit.DB.XYZ(0,0,0) # Revit XYZ# 使用XYZ对象创建点revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz)OUT = revit_xyz, revit_point 我们可以从 Python 脚本节点输出 XYZ 和 Point，但是除非将它们转换为 Dynamo 类型，否则它们将在 Dynamo 几何预览中不可见： ToPoint() ToProtoType() 123revit_xyz = Autodesk.Revit.DB.XYZ(0,0,0)revit_point = Autodesk.Revit.DB.Point.Create(revit_xyz)OUT = revit_xyz.ToPoint(), revit_point.ToProtoType() Lines / Curves​​ 先看一下 Dynamo 类：Dynamo 有两个线型几何类。了解他们之间存在区别。 Autodesk.DesignScript.Geometry.Line 线段，具有起点和终点。 Autodesk.DesignScript.Geometry.Curve 复杂的曲面或 UV 坐标。Dynamo 的 Curve 类包含 Line 。 为了使这个示例简单，我们将在下面显示如何创建一条简单的 Dynamo 行。首先，我们将创建 Dynamo 点，然后将其用作定义直线的起点和终点。 1234dynamo_point_1 = Autodesk.DesignScript.Geometry.Point.ByCoordinates(0,0,0) # 创建起点dynamo_point_2 = Autodesk.DesignScript.Geometry.Point.ByCoordinates(10,10,0) # 创建终点dynamo_line = Autodesk.DesignScript.Geometry.Line.ByStartPointEndPoint(dynamo_point_1, dynamo_point_2) # 传入参数起点和终点创建Dynamo线段OUT = dynamo_line # 返回线段 下面尝试使用 python 脚本节点输出，并使用 ToProtoType() 将其转换为 Dynamo 几何类型，否则在 Dynamo 几何预览中将不可见。 1234revit_xyz_1 = XYZ(0,0,0)revit_xyz_2 = XYZ(10,10,0)revit_line = Line.CreateBound(revit_xyz_1, revit_xyz_2)OUT = revit_line.ToProtoType()","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.5 过滤器 FilteredElementCollector","slug":"PythonScriptPrimer/2.5 过滤器 FilteredElementCollector","date":"2021-02-09T00:08:11.000Z","updated":"2021-02-08T21:05:23.944Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.5 过滤器 FilteredElementCollector/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.5%20%E8%BF%87%E6%BB%A4%E5%99%A8%20FilteredElementCollector/","excerpt":"介绍处理模型的前提是获取到相应类型的元素。Revit 的 FilteredElementCollector 允许您使用一组自定义的过滤规则，在 Revit 文档的数据库中快速搜索元素。您可以将搜索过滤器和修饰符堆叠在一起，从而使您可以进行几乎无限次的自定义搜索。","text":"介绍处理模型的前提是获取到相应类型的元素。Revit 的 FilteredElementCollector 允许您使用一组自定义的过滤规则，在 Revit 文档的数据库中快速搜索元素。您可以将搜索过滤器和修饰符堆叠在一起，从而使您可以进行几乎无限次的自定义搜索。 举个简单的例子FilteredElementCollectors 将返回 Element 或 ElementIds 的列表。 快速组合在一起非常简单。例如： 12345all_furniture = FilteredElementCollector(doc) # 创建过滤器all_furniture.OfCategory(BuiltInCategory.OST_Furniture) # 过滤家具（包含：实例和类型）all_furniture.WhereElementIsNotElementType() # 过滤项目中家具实例all_furniture.ToElements() # 结果转换为Element对象列表OUT = all_furniture # 输出对象 这段代码首先创建一个新的 FilteredElementCollector 实例，该实例将 Revit 文档作为其构造函数中的参数。 第 4 行添加了一个进一步的过滤器-我们不想在返回的元素中仅包含家具族类型，而仅是实例。 在第 5 行中，我们指定我们希望 FilteredElementCollector 返回实际的 Revit 元素。 最后，第 6 行使用 OUT 从节点输出收集的元素。 也可以将上述脚本压缩为一行，如下所示： 12all_furniture = FilteredElementCollector(doc).OfCategory(BuiltInCategory.OST_Furniture).WhereElementIsNotElementType().ToElements()OUT = all_furniture 这两个脚本将返回完全相同的对象，因此可以选择使用哪个版本:较长的版本还是较冗长的版本 建议使用下面这种简洁 过滤器使用指南关于如何为元素组装基本过滤器的分步指南： 知道您要过滤的内容 如果这是 Revit 类别的元素，请在 BuiltInCategory 枚举中找到等效的 BuiltInCategory 类型。 否则，如果您正在寻找特定 API 类的元素，则可以使用 .OfClass() 过滤器，并在 Class 名称中添加一个参数类别。 您是否要返回元素实例或其类型 例如，您要查找文档中的所有 TextNotes 实例还是所有 TextNoteTypes 族类型 如果需要实例，请使用 .WhereElementIsNotElementType() 过滤器 如果需要类型，请使用 .WhereElementIsElementType() 过滤器 如果您两者都想要，则不要使用过滤器 是否要返回 Revit 元素或元素的 ID 使用 .ToElements() 或 .ToElementIds() 完成您的 FilteredElementCollector 查询。 进阶筛选上面是构建基本 FilteredElementCollector 的大致指南。但是，您可以构建更多自定义过滤器： 您可以使用 ElementLevelFilter 来过滤某个级别上托管的元素，或者使用 ElementWorksetFilter 来仅过滤特定工作集上的元素。 您可以建立自定义评估规则。是否仅在指定参数值或 Height 参数大于 3000mm 的元素中寻找元素？这些都是可以轻松实现的。 此页面只是刮擦 FilteredElementCollectors 的表面。 快速过滤器-QuickFilters ElementCategoryFilter ：与输入类别 ID 匹配的元素； 快捷方式：OfCategory ElementClassFilter：与输入运行时类匹配的元素； 快捷方式：OfClass ElementIsElementTypeFilter：是“元素类型”（符号）的元素； 快捷方式：WhereElementIsElementType / WhereElementIsNotElementType ElementOwnerViewFilter：特定于视图的元素； 快捷方式：OwnedByView / WhereElementIsViewIndependent ElementDesignOptionFilter：特定设计选项中的元素； 快捷方式：ContainedInDesignOption ElementIsCurveDrivenFilter：曲线驱动的元素； 快捷方式：WhereElementIsCurveDriven ElementStructuralTypeFilter：匹配给定结构类型的元素 FamilySymbolFilter：特定家庭的符号 ExclusionFilter：除输入到过滤器中的元素 ID 之外的所有元素 BoundingBoxIntersectsFilter：具有与给定轮廓相交的边界框的元素 BoundingBoxIsInsideFilter：在给定轮廓内具有边界框的元素 BoundingBoxContainsPointFilter：具有包含给定点的边界框的元素","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.3 了解 Doc, UIDoc, App, UIApp","slug":"PythonScriptPrimer/2.3 了解 Doc, UIDoc, App, UIApp","date":"2021-02-09T00:08:10.000Z","updated":"2021-02-08T21:56:36.640Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.3 了解 Doc, UIDoc, App, UIApp/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.3%20%E4%BA%86%E8%A7%A3%20Doc,%20UIDoc,%20App,%20UIApp/","excerpt":"样板代码正如在样板代码一章中所见，Revit 样板代码通常需要设置 Revit 应用程序和文档 doc，uidoc，app，uiapp的句柄。 但是为什么呢？","text":"样板代码正如在样板代码一章中所见，Revit 样板代码通常需要设置 Revit 应用程序和文档 doc，uidoc，app，uiapp的句柄。 但是为什么呢？ Application and Document一开始，API 的这一部分似乎有些混乱。问题比比皆是：Revit 不能仅算出我所处的文档（即模型）吗？为什么我有一个 Document 和一个 UIDocument？为什么要引用应用程序-应用程序不是 Revit 吗？ 这些是很好的问题。幸运的是，Revit 的 API 指南为我们提供了一些答案： Revit Platform API 中的顶级对象是应用程序和文档。这些由类 Application，UIApplication，Document 和 UIDocument 表示。 应用程序对象引用一个单独的 Revit 会话 提供对文档，选项以及其他应用程序范围的数据和设置的访问。 Autodesk.Revit.UI.UIApplication 提供对应用程序的 UI 级别界面的访问，包括将 RibbonPanels 添加到用户界面的能力，以及在用户界面中获取活动文档的能力。 Autodesk.Revit.ApplicationServices.Application 提供对所有其他应用程序级别属性的访问。 该文档对象是代表建筑模型的单个 Revit 项目文件 Revit 可以打开多个项目，并为一个项目提供多个视图。 Autodesk.Revit.UI.UIDocument 提供对文档的 UI 级别界面的访问，例如选择内容以及提示用户进行选择和选择点的功能 Autodesk.Revit.DB.Document 提供对所有其他文档级别属性的访问 总结 一次可以打开多个 Revit 文档（包括.rfa 文件），因此需要指定要定位的文档。 您还可以具有多个 Revit 应用程序的运行实例，因此您需要指定要定位的应用程序。 Document / UIDocument 和 Application / UIApplication 拆分是由 API 设计人员决定的。UI 类通常引用用户界面元素或需要交互的元素（例如提示用户在主 Revit 窗口中选择元素）。 主要要知道的是，我们的样板代码中的 doc，uidoc，app 和 uiapp 句柄对于涉及编辑 Revit 文档的许多操作都是必不可少的。例如，要删除某些内容？您需要参考要从中删除内容的文档！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.4 展开Revit元素","slug":"PythonScriptPrimer/2.4 展开Revit元素","date":"2021-02-09T00:08:10.000Z","updated":"2021-02-08T21:56:42.898Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.4 展开Revit元素/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.4%20%E5%B1%95%E5%BC%80Revit%E5%85%83%E7%B4%A0/","excerpt":"About Unwrapping展开元素？现在有一些奇怪的术语！简而言之：引入节点的 Revit 元素在使用前需要先’unwrapped’。 但是为了了解所有含义，我们需要对 Dynamo 的最初开发方式有一点了解。","text":"About Unwrapping展开元素？现在有一些奇怪的术语！简而言之：引入节点的 Revit 元素在使用前需要先’unwrapped’。 但是为了了解所有含义，我们需要对 Dynamo 的最初开发方式有一点了解。 回顾历史 🏰Dynamo 最初被认为是 Ian Keough 的开源爱好项目。Dynamo 最初仅用于与 Revit 集成，但它还需要 Revit API 本身不提供的扩展功能，例如可视化抽象几何。 围绕此问题的方法是，Ian 的新应用程序使用其自己的等效类型实质上封装 Revit API 中的大约 1700 个类-这些类型的功能可以根据 Dynamo 的要求进行构建。 因此，Revit 的类与 Dynamo 的等效类之间存在细微且不可察觉的差异（此类类称为“包装器类”）。 如果我们检查 Revit 对象的类名称及其等效的 Dynamo 对象，则可以看到。例如，让我们看一下 Level 对象： 在 Revit 的 API 中，Level 类的完全限定名称为：Autodesk.Revit.DB.Level 在 Dynamo 中，Level 类的完全限定名称为：Revit.Elements.Level 编码 ToRevitType通常，Dynamo 会完成这两个工作之间的所有工作，即不可见地包裹和展开包裹元素。除了编写代码时，我们不必担心具体的技术细节。 在编写 IronPython 脚本时，我们可能会将元素作为输入提供给 Python 脚本节点。在我们解开它们之前，这些元素仍将是 Dynamo 的”包装”类型。在我们这样做之前，Revit 的类型和 Dynamo 的等效类型不能很好地配合使用。 展开元素非常简单，就像这样： 123# 使用 UnwrapElement() 方法# 将 Dynamo 元素类型转换为 Revit 元素类型revitElements = UnwrapElement(IN[0]) 注意： 未能使用 UnwrapElement 本身不会引发错误，但是在读取属性或使用包装类型的方法时会出错。 无需总是解开元素 **UnwrapElement()**，仅当它们从 Python Script 节点外部传入时使用即可。 例如，当使用 FilteredElementCollector 收集元素时，我们将绕过 Dynamo 并直接与 Revit 的 API 获取数据，该 API 将 Revit 的本身类型返回给我们，所以不需要解开元素！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.2 如何阅读Revit的API文档","slug":"PythonScriptPrimer/2.2 如何阅读Revit的API文档","date":"2021-02-09T00:08:09.000Z","updated":"2021-02-08T21:56:39.846Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.2 如何阅读Revit的API文档/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.2%20%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BBRevit%E7%9A%84API%E6%96%87%E6%A1%A3/","excerpt":"使用 APIDocs.Co由于该网站对于希望熟悉 Revit API 的人来说是非常宝贵的资源，因此我们提供了使用该网站的简要指南。","text":"使用 APIDocs.Co由于该网站对于希望熟悉 Revit API 的人来说是非常宝贵的资源，因此我们提供了使用该网站的简要指南。 典型的工作流程将涉及确保已为要使用的产品选择合适版本的 API（在左窗格中），然后在 API 文档中搜索您关注的相关主题。例如，如果要了解有关 FamilyInstance 类的更多信息，只需在搜索栏中搜索它，然后从自动完成选项中选择它即可。然后，有关此类的详细信息将显示在右侧的详细信息窗格中： 这是您正在查看的页面的名称。Revit API 有超过 22,000 页，但其中的大部分都是不经常使用的！ 这个 &lt;&gt; 按钮将在几个流行的 Github 存储库中搜索有关该类的任何代码示例。 Members 将带您到显示该类的所有方法，属性，接口或构造函数的整个页面。 面向对象编程Members: 类的成员页面只是将其所有方法，属性等收集在一个页面上。如果不确定某个类是否具有特定功能，这将非常有用。 Methods: 类方法是它可以运行的功能。可以将它们视为动词 do something 的实例可以做什么。例如，FamilyInstance 类型的对象具有 flipHand() 方法，可让您翻转其处理方式。 12# 可是使用 flipHand 翻转 my_family_instance 实例对象my_family_instance.flipHand() 注意：对 Revit 文档所做的任何更改都必须在开始事务 Transaction . Properties: 属性更像是类的”形容词”，可帮助您了解有关该类特定对象（即实例）的更多状态。例如，FamilyInstance 类具有一个 HandFlipped 属性，可以查询该属性的值，反应了该特定实例的是否已翻转。 12# 这将返回True或False，具体取决于对象是否翻转is_it_handflipped = my_family_instance.HandFlipped Constructors: API 中的构造函数实际上是在告诉您如何创建类的实例。例如，XYZ 类用于在 Revit 中定义点。我们可以使用其构造函数来创建一个新的，如下所示： 12# 创建一个新的点my_point = XYZ(0,0,0) 注意：与 Dynamo 不同的是 Revit 创建的几何对象是不可见的 Enumerations: 这些也称为枚举，它们是硬编码的列表，通常不打算更改并且将选择限制为一组选项。交通信号灯状态的枚举应类似于： Red Yellow Green 因此，用户创建的任何交通信号灯对象都需要将其交通信号灯状态设置为软件供应商定义的预写状态之一。您可以选择枚举值，如下所示： 12# enum枚举中的一种预定义状态traffic_light_value = TrafficLightState.Green Revit API 中的一些关键的枚举类型： BuiltInCategory : 类型 BuiltInParameter : 参数 DisplayUnitType : 单位","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"2.1 Revit API简介","slug":"PythonScriptPrimer/2.1 Revit API简介","date":"2021-02-09T00:08:08.000Z","updated":"2021-02-08T21:04:58.065Z","comments":true,"path":"2021/02/09/PythonScriptPrimer/2.1 Revit API简介/","link":"","permalink":"https://zedmoster.github.io/2021/02/09/PythonScriptPrimer/2.1%20Revit%20API%E7%AE%80%E4%BB%8B/","excerpt":"Revit API 简介Revit 自 2000 年代初以来就具有可访问的 API，可用于驱动该软件的几乎每个方面。由于 Revit 应用程序非常复杂，并且满足多专业功能需求（建筑结构，MEP 等），因此它的 API 非常大且需要一段时间才能直观地理解也就不足为奇了。","text":"Revit API 简介Revit 自 2000 年代初以来就具有可访问的 API，可用于驱动该软件的几乎每个方面。由于 Revit 应用程序非常复杂，并且满足多专业功能需求（建筑结构，MEP 等），因此它的 API 非常大且需要一段时间才能直观地理解也就不足为奇了。 我经常发现最容易想到 Revit 主要是一个数据库，我们在使用该应用程序时会不断对其进行更新。数据库存储我们的内容（其元素 ID，类别，位置等）。在此之上是 GUI，它表示 3D 空间中元素的几何形状/位置，并让我们与元素进行交互。 最后，还有一点网络魔术可以使我们跨局域网/ Revit Server / BIM360 设置工作共享。 以这种方式思考 Revit 与大多数用户体验该软件的方式完全不同。实际上，当我们针对 Revit 的 API 编写脚本时，我们只是对数据库进行了一系列调用，受该 API 规则的约束。 版本和历史对于 Revit 的每个发行版和子发行版，Autodesk Revit 团队都会对其 API 进行较小的更新或添加。这些更改主要与软件本身的功能更改有关。 Revit SDK &amp; API 文档软件开发套件（SDK）是软件供应商向开发人员分发有关其 API 的信息的一种常用方法。可以在找到官方的 Revit SDK 。 官方 SDK 点击下载 所有 API 都需要技术文档，因此程序员可以选择它们并学习如何使用代码来驱动应用程序。Revit SDK 包含.chm 文件中的官方 API 文档以及代码示例（用 Visual Basic 和 C＃编写）。 但是，本指南建议阅读 APIDocs.co 网站上的 Revit API ，这比打开 .chm 文件方便许多。 APIDocs.co","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.3 基本：输入和输出","slug":"PythonScriptPrimer/1.3 基本：输入和输出","date":"2021-02-08T12:05:00.000Z","updated":"2021-02-08T12:14:10.913Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.3 基本：输入和输出/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.3%20%E5%9F%BA%E6%9C%AC%EF%BC%9A%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA/","excerpt":"输入和输出IN 和 OUT 是 Dynamo 的 Python 节点中的重要关键字。IN 关键字告诉节点引用通过其输入发送到节点的任何数据。 注意：后面所有的程序代码均运行在模板文件代码块内","text":"输入和输出IN 和 OUT 是 Dynamo 的 Python 节点中的重要关键字。IN 关键字告诉节点引用通过其输入发送到节点的任何数据。 注意：后面所有的程序代码均运行在模板文件代码块内 通过它们的索引可以访问各种输入，例如下面的 list_of_numbers： 12345678input_list_of_numbers = IN[0] # 获取外部节点输入output_list_of_numbers = [] # 创建空列表作为输出的内容for number in input_list_of_numbers: new_number = number + 1 output_list_of_numbers.append(new_number)OUT = output_list_of_numbers # 输出新的列表内容（传入的值每个数字均进行 +1 操作） 在此示例中，我们最初为输出创建一个空列表。我们遍历输入列表中的每个数字，并将其进行 +1 操作后添加到我们创建的输出列表中。最后，通过 OUT 关键字输出列表。 实际上，它看起来像这样： 输入和输出的类型Dynamo 节点可以将任何种类的数据作为输入，并可以输出任何种类的数据作为输出。 它能够将元素（例如 Revit 元素），抽象数字，字符串，Dynamo 几何图形以及其他所有内容作为输入。 但是，将 Revit 元素输入到 Python 节点时有一个警告。 Revit 元素需要进行转换类型后，才能通过 API 进行访问。 了解 Dynamo Revit 数据类型转换","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.2 样板代码设置","slug":"PythonScriptPrimer/1.2 样板代码设置","date":"2021-02-08T12:00:50.000Z","updated":"2021-02-08T12:12:54.275Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.2 样板代码设置/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.2%20%E6%A0%B7%E6%9D%BF%E4%BB%A3%E7%A0%81%E8%AE%BE%E7%BD%AE/","excerpt":"样板代码设置复制代码文件到本地保存为 RevitApi.py","text":"样板代码设置复制代码文件到本地保存为 RevitApi.py 1234567891011121314151617181920212223242526272829303132333435import clrimport syssys.path.append(&#x27;C:\\Program Files (x86)\\IronPython 2.7\\Lib&#x27;)import Systemfrom System import Arrayfrom System.Collections.Generic import *clr.AddReference(&#x27;ProtoGeometry&#x27;)from Autodesk.DesignScript.Geometry import *clr.AddReference(&quot;RevitNodes&quot;)import Revitclr.ImportExtensions(Revit.Elements)clr.ImportExtensions(Revit.GeometryConversion)clr.AddReference(&quot;RevitServices&quot;)import RevitServicesfrom RevitServices.Persistence import DocumentManagerfrom RevitServices.Transactions import TransactionManagerclr.AddReference(&quot;RevitAPI&quot;)clr.AddReference(&quot;RevitAPIUI&quot;)import Autodeskfrom Autodesk.Revit.DB import *from Autodesk.Revit.UI import *doc = DocumentManager.Instance.CurrentDBDocumentuiapp = DocumentManager.Instance.CurrentUIApplicationapp = uiapp.Applicationuidoc = uiapp.ActiveUIDocumentTransactionManager.Instance.EnsureInTransaction(doc) # 事务开始####### 逻辑代码 ########TransactionManager.Instance.TransactionTaskDone() # 事务结束OUT = doc Python Script 样板文件Dynamo 2.0 开始,引入 Python 脚本模板。默认应用变量会自动添加到 Python Script 节点 复制文件RevitBoilerplate.py到位置位于 Dynamo 安装的 APPDATA 位置。 路径：%appdata%\\Dynamo\\Dynamo Revit\\{version}\\ 修改文件DynamoSettings.xml中的 PythonTemplateFilePath 内容 123&lt;PythonTemplateFilePath&gt; C:\\Users\\&#123;USERNAME&#125;\\AppData\\Roaming\\Dynamo\\Dynamo Revit\\&#123;version&#125;\\RevitBoilerplate.py&lt;/PythonTemplateFilePath&gt; 完成上面的设置之后。就可以使用 Dynamo 愉快编写 python 脚本操控 Revit 软件！","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]},{"title":"1.1 Dynamo's Python编辑器","slug":"PythonScriptPrimer/1.1 Dynamo's Python编辑器","date":"2021-02-08T11:49:51.000Z","updated":"2021-02-08T12:12:41.712Z","comments":true,"path":"2021/02/08/PythonScriptPrimer/1.1 Dynamo's Python编辑器/","link":"","permalink":"https://zedmoster.github.io/2021/02/08/PythonScriptPrimer/1.1%20Dynamo's%20Python%E7%BC%96%E8%BE%91%E5%99%A8/","excerpt":"Dynamo 的 Python 脚本编辑器Python 脚本节点随 Dynamo 一起安装，并且在许多方面，它与任何其他节点一样：可以放置在工作空间中，重命名并可以接受任意数量的输入。","text":"Dynamo 的 Python 脚本编辑器Python 脚本节点随 Dynamo 一起安装，并且在许多方面，它与任何其他节点一样：可以放置在工作空间中，重命名并可以接受任意数量的输入。 但是，与其他节点不同，如果右键单击并选择 Edit.. 则会出现一个脚本编辑窗口(双击节点)，如下所示： 在此窗口中，您可以编写 IronPython 脚本，这些脚本将作为 Dynamo 定义的一部分直接执行。要保存脚本，请单击 保存更改 按钮，然后保存其中的 Dynamo 定义。否则，请单击“取消”按钮以放弃所做的任何更改。 如何编写程序使用 Dynamo 编写 Python 代码！后面会学习设置样板代码，引用 Revit Api。 dynamo 手册","categories":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"},{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"}]}],"categories":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/categories/python/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zedmoster.github.io/categories/ffmpeg/"},{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/categories/linux/"},{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/categories/dynamo/"}],"tags":[{"name":"python","slug":"python","permalink":"https://zedmoster.github.io/tags/python/"},{"name":"pandas","slug":"pandas","permalink":"https://zedmoster.github.io/tags/pandas/"},{"name":"ffmpeg","slug":"ffmpeg","permalink":"https://zedmoster.github.io/tags/ffmpeg/"},{"name":"linux","slug":"linux","permalink":"https://zedmoster.github.io/tags/linux/"},{"name":"Shell","slug":"Shell","permalink":"https://zedmoster.github.io/tags/Shell/"},{"name":"git","slug":"git","permalink":"https://zedmoster.github.io/tags/git/"},{"name":"dynamo","slug":"dynamo","permalink":"https://zedmoster.github.io/tags/dynamo/"}]}